<?php
/**
 * Task
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Nutanix Intentful API
 *
 * Move programming from the user to the machine.
 *
 * The version of the OpenAPI document: 3.1.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * Task Class Doc Comment
 *
 * @category Class
 * @description Task details.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Task implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'task';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'status' => 'string',
        'last_update_time' => '\DateTime',
        'error_detail' => 'string',
        'logical_timestamp' => 'int',
        'requested_status' => 'string',
        'entity_reference_list' => '\OpenAPI\Client\Model\Reference[]',
        'start_time' => '\DateTime',
        'creation_time' => '\DateTime',
        'uuid' => 'string',
        'start_time_usecs' => 'int',
        'cluster_reference' => '\OpenAPI\Client\Model\ClusterReference',
        'subtask_reference_list' => '\OpenAPI\Client\Model\TaskReference[]',
        'completion_time' => '\DateTime',
        'creation_time_usecs' => 'int',
        'progress_message' => 'string',
        'operation_type' => 'string',
        'completion_time_usecs' => 'int',
        'error_code' => 'string',
        'percentage_complete' => 'int',
        'api_version' => 'string',
        'parent_task_reference' => '\OpenAPI\Client\Model\TaskReference'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'status' => null,
        'last_update_time' => 'date-time',
        'error_detail' => null,
        'logical_timestamp' => 'int64',
        'requested_status' => null,
        'entity_reference_list' => null,
        'start_time' => 'date-time',
        'creation_time' => 'date-time',
        'uuid' => 'UUID',
        'start_time_usecs' => 'int64',
        'cluster_reference' => null,
        'subtask_reference_list' => null,
        'completion_time' => 'date-time',
        'creation_time_usecs' => 'int64',
        'progress_message' => null,
        'operation_type' => null,
        'completion_time_usecs' => 'int64',
        'error_code' => null,
        'percentage_complete' => 'int32',
        'api_version' => null,
        'parent_task_reference' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'status' => false,
        'last_update_time' => false,
        'error_detail' => false,
        'logical_timestamp' => false,
        'requested_status' => false,
        'entity_reference_list' => false,
        'start_time' => false,
        'creation_time' => false,
        'uuid' => false,
        'start_time_usecs' => false,
        'cluster_reference' => false,
        'subtask_reference_list' => false,
        'completion_time' => false,
        'creation_time_usecs' => false,
        'progress_message' => false,
        'operation_type' => false,
        'completion_time_usecs' => false,
        'error_code' => false,
        'percentage_complete' => false,
        'api_version' => false,
        'parent_task_reference' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'status' => 'status',
        'last_update_time' => 'last_update_time',
        'error_detail' => 'error_detail',
        'logical_timestamp' => 'logical_timestamp',
        'requested_status' => 'requested_status',
        'entity_reference_list' => 'entity_reference_list',
        'start_time' => 'start_time',
        'creation_time' => 'creation_time',
        'uuid' => 'uuid',
        'start_time_usecs' => 'start_time_usecs',
        'cluster_reference' => 'cluster_reference',
        'subtask_reference_list' => 'subtask_reference_list',
        'completion_time' => 'completion_time',
        'creation_time_usecs' => 'creation_time_usecs',
        'progress_message' => 'progress_message',
        'operation_type' => 'operation_type',
        'completion_time_usecs' => 'completion_time_usecs',
        'error_code' => 'error_code',
        'percentage_complete' => 'percentage_complete',
        'api_version' => 'api_version',
        'parent_task_reference' => 'parent_task_reference'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'status' => 'setStatus',
        'last_update_time' => 'setLastUpdateTime',
        'error_detail' => 'setErrorDetail',
        'logical_timestamp' => 'setLogicalTimestamp',
        'requested_status' => 'setRequestedStatus',
        'entity_reference_list' => 'setEntityReferenceList',
        'start_time' => 'setStartTime',
        'creation_time' => 'setCreationTime',
        'uuid' => 'setUuid',
        'start_time_usecs' => 'setStartTimeUsecs',
        'cluster_reference' => 'setClusterReference',
        'subtask_reference_list' => 'setSubtaskReferenceList',
        'completion_time' => 'setCompletionTime',
        'creation_time_usecs' => 'setCreationTimeUsecs',
        'progress_message' => 'setProgressMessage',
        'operation_type' => 'setOperationType',
        'completion_time_usecs' => 'setCompletionTimeUsecs',
        'error_code' => 'setErrorCode',
        'percentage_complete' => 'setPercentageComplete',
        'api_version' => 'setApiVersion',
        'parent_task_reference' => 'setParentTaskReference'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'status' => 'getStatus',
        'last_update_time' => 'getLastUpdateTime',
        'error_detail' => 'getErrorDetail',
        'logical_timestamp' => 'getLogicalTimestamp',
        'requested_status' => 'getRequestedStatus',
        'entity_reference_list' => 'getEntityReferenceList',
        'start_time' => 'getStartTime',
        'creation_time' => 'getCreationTime',
        'uuid' => 'getUuid',
        'start_time_usecs' => 'getStartTimeUsecs',
        'cluster_reference' => 'getClusterReference',
        'subtask_reference_list' => 'getSubtaskReferenceList',
        'completion_time' => 'getCompletionTime',
        'creation_time_usecs' => 'getCreationTimeUsecs',
        'progress_message' => 'getProgressMessage',
        'operation_type' => 'getOperationType',
        'completion_time_usecs' => 'getCompletionTimeUsecs',
        'error_code' => 'getErrorCode',
        'percentage_complete' => 'getPercentageComplete',
        'api_version' => 'getApiVersion',
        'parent_task_reference' => 'getParentTaskReference'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('last_update_time', $data ?? [], null);
        $this->setIfExists('error_detail', $data ?? [], null);
        $this->setIfExists('logical_timestamp', $data ?? [], null);
        $this->setIfExists('requested_status', $data ?? [], null);
        $this->setIfExists('entity_reference_list', $data ?? [], null);
        $this->setIfExists('start_time', $data ?? [], null);
        $this->setIfExists('creation_time', $data ?? [], null);
        $this->setIfExists('uuid', $data ?? [], null);
        $this->setIfExists('start_time_usecs', $data ?? [], null);
        $this->setIfExists('cluster_reference', $data ?? [], null);
        $this->setIfExists('subtask_reference_list', $data ?? [], null);
        $this->setIfExists('completion_time', $data ?? [], null);
        $this->setIfExists('creation_time_usecs', $data ?? [], null);
        $this->setIfExists('progress_message', $data ?? [], null);
        $this->setIfExists('operation_type', $data ?? [], null);
        $this->setIfExists('completion_time_usecs', $data ?? [], null);
        $this->setIfExists('error_code', $data ?? [], null);
        $this->setIfExists('percentage_complete', $data ?? [], null);
        $this->setIfExists('api_version', $data ?? [], '3.1.0');
        $this->setIfExists('parent_task_reference', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['uuid']) && !preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $this->container['uuid'])) {
            $invalidProperties[] = "invalid value for 'uuid', must be conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status Current state of the task.
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets last_update_time
     *
     * @return \DateTime|null
     */
    public function getLastUpdateTime()
    {
        return $this->container['last_update_time'];
    }

    /**
     * Sets last_update_time
     *
     * @param \DateTime|null $last_update_time UTC date and time in RFC-3339 format when task was last updated.
     *
     * @return self
     */
    public function setLastUpdateTime($last_update_time)
    {
        if (is_null($last_update_time)) {
            throw new \InvalidArgumentException('non-nullable last_update_time cannot be null');
        }
        $this->container['last_update_time'] = $last_update_time;

        return $this;
    }

    /**
     * Gets error_detail
     *
     * @return string|null
     */
    public function getErrorDetail()
    {
        return $this->container['error_detail'];
    }

    /**
     * Sets error_detail
     *
     * @param string|null $error_detail In case of task failure this field will provide the error description.
     *
     * @return self
     */
    public function setErrorDetail($error_detail)
    {
        if (is_null($error_detail)) {
            throw new \InvalidArgumentException('non-nullable error_detail cannot be null');
        }
        $this->container['error_detail'] = $error_detail;

        return $this;
    }

    /**
     * Gets logical_timestamp
     *
     * @return int|null
     */
    public function getLogicalTimestamp()
    {
        return $this->container['logical_timestamp'];
    }

    /**
     * Sets logical_timestamp
     *
     * @param int|null $logical_timestamp Number of times the task has been updated. The value increases sequentially with each update of the task and can be used to verify if there have been changes to the task.
     *
     * @return self
     */
    public function setLogicalTimestamp($logical_timestamp)
    {
        if (is_null($logical_timestamp)) {
            throw new \InvalidArgumentException('non-nullable logical_timestamp cannot be null');
        }
        $this->container['logical_timestamp'] = $logical_timestamp;

        return $this;
    }

    /**
     * Gets requested_status
     *
     * @return string|null
     */
    public function getRequestedStatus()
    {
        return $this->container['requested_status'];
    }

    /**
     * Sets requested_status
     *
     * @param string|null $requested_status Final expected state of the task. It is set when the task is aborted.
     *
     * @return self
     */
    public function setRequestedStatus($requested_status)
    {
        if (is_null($requested_status)) {
            throw new \InvalidArgumentException('non-nullable requested_status cannot be null');
        }
        $this->container['requested_status'] = $requested_status;

        return $this;
    }

    /**
     * Gets entity_reference_list
     *
     * @return \OpenAPI\Client\Model\Reference[]|null
     */
    public function getEntityReferenceList()
    {
        return $this->container['entity_reference_list'];
    }

    /**
     * Sets entity_reference_list
     *
     * @param \OpenAPI\Client\Model\Reference[]|null $entity_reference_list entity_reference_list
     *
     * @return self
     */
    public function setEntityReferenceList($entity_reference_list)
    {
        if (is_null($entity_reference_list)) {
            throw new \InvalidArgumentException('non-nullable entity_reference_list cannot be null');
        }
        $this->container['entity_reference_list'] = $entity_reference_list;

        return $this;
    }

    /**
     * Gets start_time
     *
     * @return \DateTime|null
     */
    public function getStartTime()
    {
        return $this->container['start_time'];
    }

    /**
     * Sets start_time
     *
     * @param \DateTime|null $start_time UTC date and time in RFC-3339 format when Task execution started.
     *
     * @return self
     */
    public function setStartTime($start_time)
    {
        if (is_null($start_time)) {
            throw new \InvalidArgumentException('non-nullable start_time cannot be null');
        }
        $this->container['start_time'] = $start_time;

        return $this;
    }

    /**
     * Gets creation_time
     *
     * @return \DateTime|null
     */
    public function getCreationTime()
    {
        return $this->container['creation_time'];
    }

    /**
     * Sets creation_time
     *
     * @param \DateTime|null $creation_time UTC date and time in RFC-3339 format when task was created.
     *
     * @return self
     */
    public function setCreationTime($creation_time)
    {
        if (is_null($creation_time)) {
            throw new \InvalidArgumentException('non-nullable creation_time cannot be null');
        }
        $this->container['creation_time'] = $creation_time;

        return $this;
    }

    /**
     * Gets uuid
     *
     * @return string|null
     */
    public function getUuid()
    {
        return $this->container['uuid'];
    }

    /**
     * Sets uuid
     *
     * @param string|null $uuid UUID of the task.
     *
     * @return self
     */
    public function setUuid($uuid)
    {
        if (is_null($uuid)) {
            throw new \InvalidArgumentException('non-nullable uuid cannot be null');
        }

        if ((!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", ObjectSerializer::toString($uuid)))) {
            throw new \InvalidArgumentException("invalid value for \$uuid when calling Task., must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }

        $this->container['uuid'] = $uuid;

        return $this;
    }

    /**
     * Gets start_time_usecs
     *
     * @return int|null
     */
    public function getStartTimeUsecs()
    {
        return $this->container['start_time_usecs'];
    }

    /**
     * Sets start_time_usecs
     *
     * @param int|null $start_time_usecs Time in microseconds from epoch when the task execution started.
     *
     * @return self
     */
    public function setStartTimeUsecs($start_time_usecs)
    {
        if (is_null($start_time_usecs)) {
            throw new \InvalidArgumentException('non-nullable start_time_usecs cannot be null');
        }
        $this->container['start_time_usecs'] = $start_time_usecs;

        return $this;
    }

    /**
     * Gets cluster_reference
     *
     * @return \OpenAPI\Client\Model\ClusterReference|null
     */
    public function getClusterReference()
    {
        return $this->container['cluster_reference'];
    }

    /**
     * Sets cluster_reference
     *
     * @param \OpenAPI\Client\Model\ClusterReference|null $cluster_reference cluster_reference
     *
     * @return self
     */
    public function setClusterReference($cluster_reference)
    {
        if (is_null($cluster_reference)) {
            throw new \InvalidArgumentException('non-nullable cluster_reference cannot be null');
        }
        $this->container['cluster_reference'] = $cluster_reference;

        return $this;
    }

    /**
     * Gets subtask_reference_list
     *
     * @return \OpenAPI\Client\Model\TaskReference[]|null
     */
    public function getSubtaskReferenceList()
    {
        return $this->container['subtask_reference_list'];
    }

    /**
     * Sets subtask_reference_list
     *
     * @param \OpenAPI\Client\Model\TaskReference[]|null $subtask_reference_list Reference to the sub-tasks.
     *
     * @return self
     */
    public function setSubtaskReferenceList($subtask_reference_list)
    {
        if (is_null($subtask_reference_list)) {
            throw new \InvalidArgumentException('non-nullable subtask_reference_list cannot be null');
        }
        $this->container['subtask_reference_list'] = $subtask_reference_list;

        return $this;
    }

    /**
     * Gets completion_time
     *
     * @return \DateTime|null
     */
    public function getCompletionTime()
    {
        return $this->container['completion_time'];
    }

    /**
     * Sets completion_time
     *
     * @param \DateTime|null $completion_time UTC date and time in RFC-3339 format when Task execution completed.
     *
     * @return self
     */
    public function setCompletionTime($completion_time)
    {
        if (is_null($completion_time)) {
            throw new \InvalidArgumentException('non-nullable completion_time cannot be null');
        }
        $this->container['completion_time'] = $completion_time;

        return $this;
    }

    /**
     * Gets creation_time_usecs
     *
     * @return int|null
     */
    public function getCreationTimeUsecs()
    {
        return $this->container['creation_time_usecs'];
    }

    /**
     * Sets creation_time_usecs
     *
     * @param int|null $creation_time_usecs Time in microseconds from epoch when task was created.
     *
     * @return self
     */
    public function setCreationTimeUsecs($creation_time_usecs)
    {
        if (is_null($creation_time_usecs)) {
            throw new \InvalidArgumentException('non-nullable creation_time_usecs cannot be null');
        }
        $this->container['creation_time_usecs'] = $creation_time_usecs;

        return $this;
    }

    /**
     * Gets progress_message
     *
     * @return string|null
     */
    public function getProgressMessage()
    {
        return $this->container['progress_message'];
    }

    /**
     * Sets progress_message
     *
     * @param string|null $progress_message Description of what currently the task is doing.
     *
     * @return self
     */
    public function setProgressMessage($progress_message)
    {
        if (is_null($progress_message)) {
            throw new \InvalidArgumentException('non-nullable progress_message cannot be null');
        }
        $this->container['progress_message'] = $progress_message;

        return $this;
    }

    /**
     * Gets operation_type
     *
     * @return string|null
     */
    public function getOperationType()
    {
        return $this->container['operation_type'];
    }

    /**
     * Sets operation_type
     *
     * @param string|null $operation_type Type of the operation tracked by the task.
     *
     * @return self
     */
    public function setOperationType($operation_type)
    {
        if (is_null($operation_type)) {
            throw new \InvalidArgumentException('non-nullable operation_type cannot be null');
        }
        $this->container['operation_type'] = $operation_type;

        return $this;
    }

    /**
     * Gets completion_time_usecs
     *
     * @return int|null
     */
    public function getCompletionTimeUsecs()
    {
        return $this->container['completion_time_usecs'];
    }

    /**
     * Sets completion_time_usecs
     *
     * @param int|null $completion_time_usecs Time in microseconds from epoch when task execution completed.
     *
     * @return self
     */
    public function setCompletionTimeUsecs($completion_time_usecs)
    {
        if (is_null($completion_time_usecs)) {
            throw new \InvalidArgumentException('non-nullable completion_time_usecs cannot be null');
        }
        $this->container['completion_time_usecs'] = $completion_time_usecs;

        return $this;
    }

    /**
     * Gets error_code
     *
     * @return string|null
     */
    public function getErrorCode()
    {
        return $this->container['error_code'];
    }

    /**
     * Sets error_code
     *
     * @param string|null $error_code In case of task failure this field will provide the error code.
     *
     * @return self
     */
    public function setErrorCode($error_code)
    {
        if (is_null($error_code)) {
            throw new \InvalidArgumentException('non-nullable error_code cannot be null');
        }
        $this->container['error_code'] = $error_code;

        return $this;
    }

    /**
     * Gets percentage_complete
     *
     * @return int|null
     */
    public function getPercentageComplete()
    {
        return $this->container['percentage_complete'];
    }

    /**
     * Sets percentage_complete
     *
     * @param int|null $percentage_complete The completion percentage for the task.
     *
     * @return self
     */
    public function setPercentageComplete($percentage_complete)
    {
        if (is_null($percentage_complete)) {
            throw new \InvalidArgumentException('non-nullable percentage_complete cannot be null');
        }
        $this->container['percentage_complete'] = $percentage_complete;

        return $this;
    }

    /**
     * Gets api_version
     *
     * @return string|null
     */
    public function getApiVersion()
    {
        return $this->container['api_version'];
    }

    /**
     * Sets api_version
     *
     * @param string|null $api_version API Version of the Nutanix v3 API framework.
     *
     * @return self
     */
    public function setApiVersion($api_version)
    {
        if (is_null($api_version)) {
            throw new \InvalidArgumentException('non-nullable api_version cannot be null');
        }
        $this->container['api_version'] = $api_version;

        return $this;
    }

    /**
     * Gets parent_task_reference
     *
     * @return \OpenAPI\Client\Model\TaskReference|null
     */
    public function getParentTaskReference()
    {
        return $this->container['parent_task_reference'];
    }

    /**
     * Sets parent_task_reference
     *
     * @param \OpenAPI\Client\Model\TaskReference|null $parent_task_reference parent_task_reference
     *
     * @return self
     */
    public function setParentTaskReference($parent_task_reference)
    {
        if (is_null($parent_task_reference)) {
            throw new \InvalidArgumentException('non-nullable parent_task_reference cannot be null');
        }
        $this->container['parent_task_reference'] = $parent_task_reference;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


