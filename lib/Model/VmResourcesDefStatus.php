<?php
/**
 * VmResourcesDefStatus
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Nutanix Intentful API
 *
 * Move programming from the user to the machine.
 *
 * The version of the OpenAPI document: 3.1.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * VmResourcesDefStatus Class Doc Comment
 *
 * @category Class
 * @description VM Resources Status Definition.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class VmResourcesDefStatus implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'vm_resources_def_status';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'num_threads_per_core' => 'int',
        'is_agent_vm' => 'bool',
        'protection_policy_state' => '\OpenAPI\Client\Model\ProtectionPolicyState',
        'memory_size_mib' => 'int',
        'boot_config' => '\OpenAPI\Client\Model\VmBootConfig',
        'disk_list' => '\OpenAPI\Client\Model\VmDiskOutputStatus[]',
        'serial_port_list' => '\OpenAPI\Client\Model\SerialPort[]',
        'is_vcpu_hard_pinned' => 'bool',
        'power_state' => 'string',
        'recovery_plan_state_list' => '\OpenAPI\Client\Model\RecoveryPlanPolicyState[]',
        'effective_storage_config' => '\OpenAPI\Client\Model\EffectiveStorageConfig',
        'num_vcpus_per_socket' => 'int',
        'num_sockets' => 'int',
        'hardware_virtualization_enabled' => 'bool',
        'storage_config' => '\OpenAPI\Client\Model\VmStorageConfigStatus',
        'protection_type' => 'string',
        'gpu_list' => '\OpenAPI\Client\Model\VmGpuOutputStatus[]',
        'machine_type' => 'string',
        'hardware_clock_timezone' => 'string',
        'guest_customization' => '\OpenAPI\Client\Model\GuestCustomizationStatus',
        'power_state_mechanism' => '\OpenAPI\Client\Model\VmPowerStateMechanism',
        'vga_console_enabled' => 'bool',
        'memory_overcommit_enabled' => 'bool',
        'vnuma_config' => '\OpenAPI\Client\Model\VmVnumaConfig',
        'nic_list' => '\OpenAPI\Client\Model\VmNicOutputStatus[]',
        'host_reference' => '\OpenAPI\Client\Model\Reference',
        'guest_os_id' => 'string',
        'guest_tools' => '\OpenAPI\Client\Model\GuestToolsStatus',
        'gpu_console_enabled' => 'bool',
        'vtpm_config' => '\OpenAPI\Client\Model\VmVtpmStatus',
        'enable_cpu_passthrough' => 'bool',
        'parent_reference' => '\OpenAPI\Client\Model\Reference',
        'hypervisor_type' => 'string',
        'disable_branding' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'num_threads_per_core' => 'int32',
        'is_agent_vm' => null,
        'protection_policy_state' => null,
        'memory_size_mib' => 'int32',
        'boot_config' => null,
        'disk_list' => null,
        'serial_port_list' => null,
        'is_vcpu_hard_pinned' => null,
        'power_state' => null,
        'recovery_plan_state_list' => null,
        'effective_storage_config' => null,
        'num_vcpus_per_socket' => 'int32',
        'num_sockets' => 'int32',
        'hardware_virtualization_enabled' => null,
        'storage_config' => null,
        'protection_type' => null,
        'gpu_list' => null,
        'machine_type' => null,
        'hardware_clock_timezone' => null,
        'guest_customization' => null,
        'power_state_mechanism' => null,
        'vga_console_enabled' => null,
        'memory_overcommit_enabled' => null,
        'vnuma_config' => null,
        'nic_list' => null,
        'host_reference' => null,
        'guest_os_id' => null,
        'guest_tools' => null,
        'gpu_console_enabled' => null,
        'vtpm_config' => null,
        'enable_cpu_passthrough' => null,
        'parent_reference' => null,
        'hypervisor_type' => null,
        'disable_branding' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'num_threads_per_core' => false,
        'is_agent_vm' => false,
        'protection_policy_state' => false,
        'memory_size_mib' => false,
        'boot_config' => false,
        'disk_list' => false,
        'serial_port_list' => false,
        'is_vcpu_hard_pinned' => false,
        'power_state' => false,
        'recovery_plan_state_list' => false,
        'effective_storage_config' => false,
        'num_vcpus_per_socket' => false,
        'num_sockets' => false,
        'hardware_virtualization_enabled' => false,
        'storage_config' => false,
        'protection_type' => false,
        'gpu_list' => false,
        'machine_type' => false,
        'hardware_clock_timezone' => false,
        'guest_customization' => false,
        'power_state_mechanism' => false,
        'vga_console_enabled' => false,
        'memory_overcommit_enabled' => false,
        'vnuma_config' => false,
        'nic_list' => false,
        'host_reference' => false,
        'guest_os_id' => false,
        'guest_tools' => false,
        'gpu_console_enabled' => false,
        'vtpm_config' => false,
        'enable_cpu_passthrough' => false,
        'parent_reference' => false,
        'hypervisor_type' => false,
        'disable_branding' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'num_threads_per_core' => 'num_threads_per_core',
        'is_agent_vm' => 'is_agent_vm',
        'protection_policy_state' => 'protection_policy_state',
        'memory_size_mib' => 'memory_size_mib',
        'boot_config' => 'boot_config',
        'disk_list' => 'disk_list',
        'serial_port_list' => 'serial_port_list',
        'is_vcpu_hard_pinned' => 'is_vcpu_hard_pinned',
        'power_state' => 'power_state',
        'recovery_plan_state_list' => 'recovery_plan_state_list',
        'effective_storage_config' => 'effective_storage_config',
        'num_vcpus_per_socket' => 'num_vcpus_per_socket',
        'num_sockets' => 'num_sockets',
        'hardware_virtualization_enabled' => 'hardware_virtualization_enabled',
        'storage_config' => 'storage_config',
        'protection_type' => 'protection_type',
        'gpu_list' => 'gpu_list',
        'machine_type' => 'machine_type',
        'hardware_clock_timezone' => 'hardware_clock_timezone',
        'guest_customization' => 'guest_customization',
        'power_state_mechanism' => 'power_state_mechanism',
        'vga_console_enabled' => 'vga_console_enabled',
        'memory_overcommit_enabled' => 'memory_overcommit_enabled',
        'vnuma_config' => 'vnuma_config',
        'nic_list' => 'nic_list',
        'host_reference' => 'host_reference',
        'guest_os_id' => 'guest_os_id',
        'guest_tools' => 'guest_tools',
        'gpu_console_enabled' => 'gpu_console_enabled',
        'vtpm_config' => 'vtpm_config',
        'enable_cpu_passthrough' => 'enable_cpu_passthrough',
        'parent_reference' => 'parent_reference',
        'hypervisor_type' => 'hypervisor_type',
        'disable_branding' => 'disable_branding'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'num_threads_per_core' => 'setNumThreadsPerCore',
        'is_agent_vm' => 'setIsAgentVm',
        'protection_policy_state' => 'setProtectionPolicyState',
        'memory_size_mib' => 'setMemorySizeMib',
        'boot_config' => 'setBootConfig',
        'disk_list' => 'setDiskList',
        'serial_port_list' => 'setSerialPortList',
        'is_vcpu_hard_pinned' => 'setIsVcpuHardPinned',
        'power_state' => 'setPowerState',
        'recovery_plan_state_list' => 'setRecoveryPlanStateList',
        'effective_storage_config' => 'setEffectiveStorageConfig',
        'num_vcpus_per_socket' => 'setNumVcpusPerSocket',
        'num_sockets' => 'setNumSockets',
        'hardware_virtualization_enabled' => 'setHardwareVirtualizationEnabled',
        'storage_config' => 'setStorageConfig',
        'protection_type' => 'setProtectionType',
        'gpu_list' => 'setGpuList',
        'machine_type' => 'setMachineType',
        'hardware_clock_timezone' => 'setHardwareClockTimezone',
        'guest_customization' => 'setGuestCustomization',
        'power_state_mechanism' => 'setPowerStateMechanism',
        'vga_console_enabled' => 'setVgaConsoleEnabled',
        'memory_overcommit_enabled' => 'setMemoryOvercommitEnabled',
        'vnuma_config' => 'setVnumaConfig',
        'nic_list' => 'setNicList',
        'host_reference' => 'setHostReference',
        'guest_os_id' => 'setGuestOsId',
        'guest_tools' => 'setGuestTools',
        'gpu_console_enabled' => 'setGpuConsoleEnabled',
        'vtpm_config' => 'setVtpmConfig',
        'enable_cpu_passthrough' => 'setEnableCpuPassthrough',
        'parent_reference' => 'setParentReference',
        'hypervisor_type' => 'setHypervisorType',
        'disable_branding' => 'setDisableBranding'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'num_threads_per_core' => 'getNumThreadsPerCore',
        'is_agent_vm' => 'getIsAgentVm',
        'protection_policy_state' => 'getProtectionPolicyState',
        'memory_size_mib' => 'getMemorySizeMib',
        'boot_config' => 'getBootConfig',
        'disk_list' => 'getDiskList',
        'serial_port_list' => 'getSerialPortList',
        'is_vcpu_hard_pinned' => 'getIsVcpuHardPinned',
        'power_state' => 'getPowerState',
        'recovery_plan_state_list' => 'getRecoveryPlanStateList',
        'effective_storage_config' => 'getEffectiveStorageConfig',
        'num_vcpus_per_socket' => 'getNumVcpusPerSocket',
        'num_sockets' => 'getNumSockets',
        'hardware_virtualization_enabled' => 'getHardwareVirtualizationEnabled',
        'storage_config' => 'getStorageConfig',
        'protection_type' => 'getProtectionType',
        'gpu_list' => 'getGpuList',
        'machine_type' => 'getMachineType',
        'hardware_clock_timezone' => 'getHardwareClockTimezone',
        'guest_customization' => 'getGuestCustomization',
        'power_state_mechanism' => 'getPowerStateMechanism',
        'vga_console_enabled' => 'getVgaConsoleEnabled',
        'memory_overcommit_enabled' => 'getMemoryOvercommitEnabled',
        'vnuma_config' => 'getVnumaConfig',
        'nic_list' => 'getNicList',
        'host_reference' => 'getHostReference',
        'guest_os_id' => 'getGuestOsId',
        'guest_tools' => 'getGuestTools',
        'gpu_console_enabled' => 'getGpuConsoleEnabled',
        'vtpm_config' => 'getVtpmConfig',
        'enable_cpu_passthrough' => 'getEnableCpuPassthrough',
        'parent_reference' => 'getParentReference',
        'hypervisor_type' => 'getHypervisorType',
        'disable_branding' => 'getDisableBranding'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('num_threads_per_core', $data ?? [], null);
        $this->setIfExists('is_agent_vm', $data ?? [], null);
        $this->setIfExists('protection_policy_state', $data ?? [], null);
        $this->setIfExists('memory_size_mib', $data ?? [], null);
        $this->setIfExists('boot_config', $data ?? [], null);
        $this->setIfExists('disk_list', $data ?? [], null);
        $this->setIfExists('serial_port_list', $data ?? [], null);
        $this->setIfExists('is_vcpu_hard_pinned', $data ?? [], null);
        $this->setIfExists('power_state', $data ?? [], null);
        $this->setIfExists('recovery_plan_state_list', $data ?? [], null);
        $this->setIfExists('effective_storage_config', $data ?? [], null);
        $this->setIfExists('num_vcpus_per_socket', $data ?? [], null);
        $this->setIfExists('num_sockets', $data ?? [], null);
        $this->setIfExists('hardware_virtualization_enabled', $data ?? [], null);
        $this->setIfExists('storage_config', $data ?? [], null);
        $this->setIfExists('protection_type', $data ?? [], null);
        $this->setIfExists('gpu_list', $data ?? [], null);
        $this->setIfExists('machine_type', $data ?? [], null);
        $this->setIfExists('hardware_clock_timezone', $data ?? [], null);
        $this->setIfExists('guest_customization', $data ?? [], null);
        $this->setIfExists('power_state_mechanism', $data ?? [], null);
        $this->setIfExists('vga_console_enabled', $data ?? [], null);
        $this->setIfExists('memory_overcommit_enabled', $data ?? [], null);
        $this->setIfExists('vnuma_config', $data ?? [], null);
        $this->setIfExists('nic_list', $data ?? [], null);
        $this->setIfExists('host_reference', $data ?? [], null);
        $this->setIfExists('guest_os_id', $data ?? [], null);
        $this->setIfExists('guest_tools', $data ?? [], null);
        $this->setIfExists('gpu_console_enabled', $data ?? [], null);
        $this->setIfExists('vtpm_config', $data ?? [], null);
        $this->setIfExists('enable_cpu_passthrough', $data ?? [], null);
        $this->setIfExists('parent_reference', $data ?? [], null);
        $this->setIfExists('hypervisor_type', $data ?? [], null);
        $this->setIfExists('disable_branding', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['num_threads_per_core']) && ($this->container['num_threads_per_core'] < 1)) {
            $invalidProperties[] = "invalid value for 'num_threads_per_core', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['memory_size_mib']) && ($this->container['memory_size_mib'] < 1)) {
            $invalidProperties[] = "invalid value for 'memory_size_mib', must be bigger than or equal to 1.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets num_threads_per_core
     *
     * @return int|null
     */
    public function getNumThreadsPerCore()
    {
        return $this->container['num_threads_per_core'];
    }

    /**
     * Sets num_threads_per_core
     *
     * @param int|null $num_threads_per_core Number of logical threads per core.
     *
     * @return self
     */
    public function setNumThreadsPerCore($num_threads_per_core)
    {
        if (is_null($num_threads_per_core)) {
            throw new \InvalidArgumentException('non-nullable num_threads_per_core cannot be null');
        }

        if (($num_threads_per_core < 1)) {
            throw new \InvalidArgumentException('invalid value for $num_threads_per_core when calling VmResourcesDefStatus., must be bigger than or equal to 1.');
        }

        $this->container['num_threads_per_core'] = $num_threads_per_core;

        return $this;
    }

    /**
     * Gets is_agent_vm
     *
     * @return bool|null
     */
    public function getIsAgentVm()
    {
        return $this->container['is_agent_vm'];
    }

    /**
     * Sets is_agent_vm
     *
     * @param bool|null $is_agent_vm Indicates whether the VM is an agent VM.
     *
     * @return self
     */
    public function setIsAgentVm($is_agent_vm)
    {
        if (is_null($is_agent_vm)) {
            throw new \InvalidArgumentException('non-nullable is_agent_vm cannot be null');
        }
        $this->container['is_agent_vm'] = $is_agent_vm;

        return $this;
    }

    /**
     * Gets protection_policy_state
     *
     * @return \OpenAPI\Client\Model\ProtectionPolicyState|null
     */
    public function getProtectionPolicyState()
    {
        return $this->container['protection_policy_state'];
    }

    /**
     * Sets protection_policy_state
     *
     * @param \OpenAPI\Client\Model\ProtectionPolicyState|null $protection_policy_state protection_policy_state
     *
     * @return self
     */
    public function setProtectionPolicyState($protection_policy_state)
    {
        if (is_null($protection_policy_state)) {
            throw new \InvalidArgumentException('non-nullable protection_policy_state cannot be null');
        }
        $this->container['protection_policy_state'] = $protection_policy_state;

        return $this;
    }

    /**
     * Gets memory_size_mib
     *
     * @return int|null
     */
    public function getMemorySizeMib()
    {
        return $this->container['memory_size_mib'];
    }

    /**
     * Sets memory_size_mib
     *
     * @param int|null $memory_size_mib Memory size in MiB.
     *
     * @return self
     */
    public function setMemorySizeMib($memory_size_mib)
    {
        if (is_null($memory_size_mib)) {
            throw new \InvalidArgumentException('non-nullable memory_size_mib cannot be null');
        }

        if (($memory_size_mib < 1)) {
            throw new \InvalidArgumentException('invalid value for $memory_size_mib when calling VmResourcesDefStatus., must be bigger than or equal to 1.');
        }

        $this->container['memory_size_mib'] = $memory_size_mib;

        return $this;
    }

    /**
     * Gets boot_config
     *
     * @return \OpenAPI\Client\Model\VmBootConfig|null
     */
    public function getBootConfig()
    {
        return $this->container['boot_config'];
    }

    /**
     * Sets boot_config
     *
     * @param \OpenAPI\Client\Model\VmBootConfig|null $boot_config boot_config
     *
     * @return self
     */
    public function setBootConfig($boot_config)
    {
        if (is_null($boot_config)) {
            throw new \InvalidArgumentException('non-nullable boot_config cannot be null');
        }
        $this->container['boot_config'] = $boot_config;

        return $this;
    }

    /**
     * Gets disk_list
     *
     * @return \OpenAPI\Client\Model\VmDiskOutputStatus[]|null
     */
    public function getDiskList()
    {
        return $this->container['disk_list'];
    }

    /**
     * Sets disk_list
     *
     * @param \OpenAPI\Client\Model\VmDiskOutputStatus[]|null $disk_list Disks attached to the VM.
     *
     * @return self
     */
    public function setDiskList($disk_list)
    {
        if (is_null($disk_list)) {
            throw new \InvalidArgumentException('non-nullable disk_list cannot be null');
        }
        $this->container['disk_list'] = $disk_list;

        return $this;
    }

    /**
     * Gets serial_port_list
     *
     * @return \OpenAPI\Client\Model\SerialPort[]|null
     */
    public function getSerialPortList()
    {
        return $this->container['serial_port_list'];
    }

    /**
     * Sets serial_port_list
     *
     * @param \OpenAPI\Client\Model\SerialPort[]|null $serial_port_list Serial ports configured on the VM.
     *
     * @return self
     */
    public function setSerialPortList($serial_port_list)
    {
        if (is_null($serial_port_list)) {
            throw new \InvalidArgumentException('non-nullable serial_port_list cannot be null');
        }
        $this->container['serial_port_list'] = $serial_port_list;

        return $this;
    }

    /**
     * Gets is_vcpu_hard_pinned
     *
     * @return bool|null
     */
    public function getIsVcpuHardPinned()
    {
        return $this->container['is_vcpu_hard_pinned'];
    }

    /**
     * Sets is_vcpu_hard_pinned
     *
     * @param bool|null $is_vcpu_hard_pinned Indicates whether the vCPUs should be hard pinned to specific pCPUs.
     *
     * @return self
     */
    public function setIsVcpuHardPinned($is_vcpu_hard_pinned)
    {
        if (is_null($is_vcpu_hard_pinned)) {
            throw new \InvalidArgumentException('non-nullable is_vcpu_hard_pinned cannot be null');
        }
        $this->container['is_vcpu_hard_pinned'] = $is_vcpu_hard_pinned;

        return $this;
    }

    /**
     * Gets power_state
     *
     * @return string|null
     */
    public function getPowerState()
    {
        return $this->container['power_state'];
    }

    /**
     * Sets power_state
     *
     * @param string|null $power_state Current power state of the VM.
     *
     * @return self
     */
    public function setPowerState($power_state)
    {
        if (is_null($power_state)) {
            throw new \InvalidArgumentException('non-nullable power_state cannot be null');
        }
        $this->container['power_state'] = $power_state;

        return $this;
    }

    /**
     * Gets recovery_plan_state_list
     *
     * @return \OpenAPI\Client\Model\RecoveryPlanPolicyState[]|null
     */
    public function getRecoveryPlanStateList()
    {
        return $this->container['recovery_plan_state_list'];
    }

    /**
     * Sets recovery_plan_state_list
     *
     * @param \OpenAPI\Client\Model\RecoveryPlanPolicyState[]|null $recovery_plan_state_list Status of the Recovery Plans associated with the VM.
     *
     * @return self
     */
    public function setRecoveryPlanStateList($recovery_plan_state_list)
    {
        if (is_null($recovery_plan_state_list)) {
            throw new \InvalidArgumentException('non-nullable recovery_plan_state_list cannot be null');
        }
        $this->container['recovery_plan_state_list'] = $recovery_plan_state_list;

        return $this;
    }

    /**
     * Gets effective_storage_config
     *
     * @return \OpenAPI\Client\Model\EffectiveStorageConfig|null
     */
    public function getEffectiveStorageConfig()
    {
        return $this->container['effective_storage_config'];
    }

    /**
     * Sets effective_storage_config
     *
     * @param \OpenAPI\Client\Model\EffectiveStorageConfig|null $effective_storage_config effective_storage_config
     *
     * @return self
     */
    public function setEffectiveStorageConfig($effective_storage_config)
    {
        if (is_null($effective_storage_config)) {
            throw new \InvalidArgumentException('non-nullable effective_storage_config cannot be null');
        }
        $this->container['effective_storage_config'] = $effective_storage_config;

        return $this;
    }

    /**
     * Gets num_vcpus_per_socket
     *
     * @return int|null
     */
    public function getNumVcpusPerSocket()
    {
        return $this->container['num_vcpus_per_socket'];
    }

    /**
     * Sets num_vcpus_per_socket
     *
     * @param int|null $num_vcpus_per_socket Number of vCPUs per socket.
     *
     * @return self
     */
    public function setNumVcpusPerSocket($num_vcpus_per_socket)
    {
        if (is_null($num_vcpus_per_socket)) {
            throw new \InvalidArgumentException('non-nullable num_vcpus_per_socket cannot be null');
        }
        $this->container['num_vcpus_per_socket'] = $num_vcpus_per_socket;

        return $this;
    }

    /**
     * Gets num_sockets
     *
     * @return int|null
     */
    public function getNumSockets()
    {
        return $this->container['num_sockets'];
    }

    /**
     * Sets num_sockets
     *
     * @param int|null $num_sockets Number of vCPU sockets.
     *
     * @return self
     */
    public function setNumSockets($num_sockets)
    {
        if (is_null($num_sockets)) {
            throw new \InvalidArgumentException('non-nullable num_sockets cannot be null');
        }
        $this->container['num_sockets'] = $num_sockets;

        return $this;
    }

    /**
     * Gets hardware_virtualization_enabled
     *
     * @return bool|null
     */
    public function getHardwareVirtualizationEnabled()
    {
        return $this->container['hardware_virtualization_enabled'];
    }

    /**
     * Sets hardware_virtualization_enabled
     *
     * @param bool|null $hardware_virtualization_enabled Indicates whether hardware assisted virtualization should be enabled for the Guest OS. Once enabled, the Guest OS has the ability to deploy a nested hypervisor.
     *
     * @return self
     */
    public function setHardwareVirtualizationEnabled($hardware_virtualization_enabled)
    {
        if (is_null($hardware_virtualization_enabled)) {
            throw new \InvalidArgumentException('non-nullable hardware_virtualization_enabled cannot be null');
        }
        $this->container['hardware_virtualization_enabled'] = $hardware_virtualization_enabled;

        return $this;
    }

    /**
     * Gets storage_config
     *
     * @return \OpenAPI\Client\Model\VmStorageConfigStatus|null
     */
    public function getStorageConfig()
    {
        return $this->container['storage_config'];
    }

    /**
     * Sets storage_config
     *
     * @param \OpenAPI\Client\Model\VmStorageConfigStatus|null $storage_config storage_config
     *
     * @return self
     */
    public function setStorageConfig($storage_config)
    {
        if (is_null($storage_config)) {
            throw new \InvalidArgumentException('non-nullable storage_config cannot be null');
        }
        $this->container['storage_config'] = $storage_config;

        return $this;
    }

    /**
     * Gets protection_type
     *
     * @return string|null
     */
    public function getProtectionType()
    {
        return $this->container['protection_type'];
    }

    /**
     * Sets protection_type
     *
     * @param string|null $protection_type The type of protection applied on a VM. PD_PROTECTED indicates a VM protected using Prism Element. RULE_PROTECTED indicates a VM protected using Prism Central.
     *
     * @return self
     */
    public function setProtectionType($protection_type)
    {
        if (is_null($protection_type)) {
            throw new \InvalidArgumentException('non-nullable protection_type cannot be null');
        }
        $this->container['protection_type'] = $protection_type;

        return $this;
    }

    /**
     * Gets gpu_list
     *
     * @return \OpenAPI\Client\Model\VmGpuOutputStatus[]|null
     */
    public function getGpuList()
    {
        return $this->container['gpu_list'];
    }

    /**
     * Sets gpu_list
     *
     * @param \OpenAPI\Client\Model\VmGpuOutputStatus[]|null $gpu_list GPUs attached to the VM.
     *
     * @return self
     */
    public function setGpuList($gpu_list)
    {
        if (is_null($gpu_list)) {
            throw new \InvalidArgumentException('non-nullable gpu_list cannot be null');
        }
        $this->container['gpu_list'] = $gpu_list;

        return $this;
    }

    /**
     * Gets machine_type
     *
     * @return string|null
     */
    public function getMachineType()
    {
        return $this->container['machine_type'];
    }

    /**
     * Sets machine_type
     *
     * @param string|null $machine_type Machine type for the VM. Machine type Q35 is required for secure boot and does not support IDE disks.
     *
     * @return self
     */
    public function setMachineType($machine_type)
    {
        if (is_null($machine_type)) {
            throw new \InvalidArgumentException('non-nullable machine_type cannot be null');
        }
        $this->container['machine_type'] = $machine_type;

        return $this;
    }

    /**
     * Gets hardware_clock_timezone
     *
     * @return string|null
     */
    public function getHardwareClockTimezone()
    {
        return $this->container['hardware_clock_timezone'];
    }

    /**
     * Sets hardware_clock_timezone
     *
     * @param string|null $hardware_clock_timezone VM's hardware clock timezone in IANA TZDB format (America/Los_Angeles).
     *
     * @return self
     */
    public function setHardwareClockTimezone($hardware_clock_timezone)
    {
        if (is_null($hardware_clock_timezone)) {
            throw new \InvalidArgumentException('non-nullable hardware_clock_timezone cannot be null');
        }
        $this->container['hardware_clock_timezone'] = $hardware_clock_timezone;

        return $this;
    }

    /**
     * Gets guest_customization
     *
     * @return \OpenAPI\Client\Model\GuestCustomizationStatus|null
     */
    public function getGuestCustomization()
    {
        return $this->container['guest_customization'];
    }

    /**
     * Sets guest_customization
     *
     * @param \OpenAPI\Client\Model\GuestCustomizationStatus|null $guest_customization guest_customization
     *
     * @return self
     */
    public function setGuestCustomization($guest_customization)
    {
        if (is_null($guest_customization)) {
            throw new \InvalidArgumentException('non-nullable guest_customization cannot be null');
        }
        $this->container['guest_customization'] = $guest_customization;

        return $this;
    }

    /**
     * Gets power_state_mechanism
     *
     * @return \OpenAPI\Client\Model\VmPowerStateMechanism|null
     */
    public function getPowerStateMechanism()
    {
        return $this->container['power_state_mechanism'];
    }

    /**
     * Sets power_state_mechanism
     *
     * @param \OpenAPI\Client\Model\VmPowerStateMechanism|null $power_state_mechanism power_state_mechanism
     *
     * @return self
     */
    public function setPowerStateMechanism($power_state_mechanism)
    {
        if (is_null($power_state_mechanism)) {
            throw new \InvalidArgumentException('non-nullable power_state_mechanism cannot be null');
        }
        $this->container['power_state_mechanism'] = $power_state_mechanism;

        return $this;
    }

    /**
     * Gets vga_console_enabled
     *
     * @return bool|null
     */
    public function getVgaConsoleEnabled()
    {
        return $this->container['vga_console_enabled'];
    }

    /**
     * Sets vga_console_enabled
     *
     * @param bool|null $vga_console_enabled Indicates whether VGA console has been enabled or not.
     *
     * @return self
     */
    public function setVgaConsoleEnabled($vga_console_enabled)
    {
        if (is_null($vga_console_enabled)) {
            throw new \InvalidArgumentException('non-nullable vga_console_enabled cannot be null');
        }
        $this->container['vga_console_enabled'] = $vga_console_enabled;

        return $this;
    }

    /**
     * Gets memory_overcommit_enabled
     *
     * @return bool|null
     */
    public function getMemoryOvercommitEnabled()
    {
        return $this->container['memory_overcommit_enabled'];
    }

    /**
     * Sets memory_overcommit_enabled
     *
     * @param bool|null $memory_overcommit_enabled Indicates whether memory overcommit feature should be enabled for the VM. If enabled, parts of the VM's memory may reside outside of the hypervisor physical memory. When enabled, it should be expected that the VM may suffer performance degradation.
     *
     * @return self
     */
    public function setMemoryOvercommitEnabled($memory_overcommit_enabled)
    {
        if (is_null($memory_overcommit_enabled)) {
            throw new \InvalidArgumentException('non-nullable memory_overcommit_enabled cannot be null');
        }
        $this->container['memory_overcommit_enabled'] = $memory_overcommit_enabled;

        return $this;
    }

    /**
     * Gets vnuma_config
     *
     * @return \OpenAPI\Client\Model\VmVnumaConfig|null
     */
    public function getVnumaConfig()
    {
        return $this->container['vnuma_config'];
    }

    /**
     * Sets vnuma_config
     *
     * @param \OpenAPI\Client\Model\VmVnumaConfig|null $vnuma_config vnuma_config
     *
     * @return self
     */
    public function setVnumaConfig($vnuma_config)
    {
        if (is_null($vnuma_config)) {
            throw new \InvalidArgumentException('non-nullable vnuma_config cannot be null');
        }
        $this->container['vnuma_config'] = $vnuma_config;

        return $this;
    }

    /**
     * Gets nic_list
     *
     * @return \OpenAPI\Client\Model\VmNicOutputStatus[]|null
     */
    public function getNicList()
    {
        return $this->container['nic_list'];
    }

    /**
     * Sets nic_list
     *
     * @param \OpenAPI\Client\Model\VmNicOutputStatus[]|null $nic_list NICs attached to the VM.
     *
     * @return self
     */
    public function setNicList($nic_list)
    {
        if (is_null($nic_list)) {
            throw new \InvalidArgumentException('non-nullable nic_list cannot be null');
        }
        $this->container['nic_list'] = $nic_list;

        return $this;
    }

    /**
     * Gets host_reference
     *
     * @return \OpenAPI\Client\Model\Reference|null
     */
    public function getHostReference()
    {
        return $this->container['host_reference'];
    }

    /**
     * Sets host_reference
     *
     * @param \OpenAPI\Client\Model\Reference|null $host_reference host_reference
     *
     * @return self
     */
    public function setHostReference($host_reference)
    {
        if (is_null($host_reference)) {
            throw new \InvalidArgumentException('non-nullable host_reference cannot be null');
        }
        $this->container['host_reference'] = $host_reference;

        return $this;
    }

    /**
     * Gets guest_os_id
     *
     * @return string|null
     */
    public function getGuestOsId()
    {
        return $this->container['guest_os_id'];
    }

    /**
     * Sets guest_os_id
     *
     * @param string|null $guest_os_id String that identifies the OS running inside of the guest. Reserved for use by the system. Do not set or modify.
     *
     * @return self
     */
    public function setGuestOsId($guest_os_id)
    {
        if (is_null($guest_os_id)) {
            throw new \InvalidArgumentException('non-nullable guest_os_id cannot be null');
        }
        $this->container['guest_os_id'] = $guest_os_id;

        return $this;
    }

    /**
     * Gets guest_tools
     *
     * @return \OpenAPI\Client\Model\GuestToolsStatus|null
     */
    public function getGuestTools()
    {
        return $this->container['guest_tools'];
    }

    /**
     * Sets guest_tools
     *
     * @param \OpenAPI\Client\Model\GuestToolsStatus|null $guest_tools guest_tools
     *
     * @return self
     */
    public function setGuestTools($guest_tools)
    {
        if (is_null($guest_tools)) {
            throw new \InvalidArgumentException('non-nullable guest_tools cannot be null');
        }
        $this->container['guest_tools'] = $guest_tools;

        return $this;
    }

    /**
     * Gets gpu_console_enabled
     *
     * @return bool|null
     */
    public function getGpuConsoleEnabled()
    {
        return $this->container['gpu_console_enabled'];
    }

    /**
     * Sets gpu_console_enabled
     *
     * @param bool|null $gpu_console_enabled Indicates whether vGPU console is enabled or not.
     *
     * @return self
     */
    public function setGpuConsoleEnabled($gpu_console_enabled)
    {
        if (is_null($gpu_console_enabled)) {
            throw new \InvalidArgumentException('non-nullable gpu_console_enabled cannot be null');
        }
        $this->container['gpu_console_enabled'] = $gpu_console_enabled;

        return $this;
    }

    /**
     * Gets vtpm_config
     *
     * @return \OpenAPI\Client\Model\VmVtpmStatus|null
     */
    public function getVtpmConfig()
    {
        return $this->container['vtpm_config'];
    }

    /**
     * Sets vtpm_config
     *
     * @param \OpenAPI\Client\Model\VmVtpmStatus|null $vtpm_config vtpm_config
     *
     * @return self
     */
    public function setVtpmConfig($vtpm_config)
    {
        if (is_null($vtpm_config)) {
            throw new \InvalidArgumentException('non-nullable vtpm_config cannot be null');
        }
        $this->container['vtpm_config'] = $vtpm_config;

        return $this;
    }

    /**
     * Gets enable_cpu_passthrough
     *
     * @return bool|null
     */
    public function getEnableCpuPassthrough()
    {
        return $this->container['enable_cpu_passthrough'];
    }

    /**
     * Sets enable_cpu_passthrough
     *
     * @param bool|null $enable_cpu_passthrough Indicates whether to passthrough the host's CPU features to the guest. Enabling this will disable live migration of the VM.
     *
     * @return self
     */
    public function setEnableCpuPassthrough($enable_cpu_passthrough)
    {
        if (is_null($enable_cpu_passthrough)) {
            throw new \InvalidArgumentException('non-nullable enable_cpu_passthrough cannot be null');
        }
        $this->container['enable_cpu_passthrough'] = $enable_cpu_passthrough;

        return $this;
    }

    /**
     * Gets parent_reference
     *
     * @return \OpenAPI\Client\Model\Reference|null
     */
    public function getParentReference()
    {
        return $this->container['parent_reference'];
    }

    /**
     * Sets parent_reference
     *
     * @param \OpenAPI\Client\Model\Reference|null $parent_reference parent_reference
     *
     * @return self
     */
    public function setParentReference($parent_reference)
    {
        if (is_null($parent_reference)) {
            throw new \InvalidArgumentException('non-nullable parent_reference cannot be null');
        }
        $this->container['parent_reference'] = $parent_reference;

        return $this;
    }

    /**
     * Gets hypervisor_type
     *
     * @return string|null
     */
    public function getHypervisorType()
    {
        return $this->container['hypervisor_type'];
    }

    /**
     * Sets hypervisor_type
     *
     * @param string|null $hypervisor_type The hypervisor type for the hypervisor the VM is hosted on.
     *
     * @return self
     */
    public function setHypervisorType($hypervisor_type)
    {
        if (is_null($hypervisor_type)) {
            throw new \InvalidArgumentException('non-nullable hypervisor_type cannot be null');
        }
        $this->container['hypervisor_type'] = $hypervisor_type;

        return $this;
    }

    /**
     * Gets disable_branding
     *
     * @return bool|null
     */
    public function getDisableBranding()
    {
        return $this->container['disable_branding'];
    }

    /**
     * Sets disable_branding
     *
     * @param bool|null $disable_branding Indicates whether to remove AHV branding from VM firmware tables.
     *
     * @return self
     */
    public function setDisableBranding($disable_branding)
    {
        if (is_null($disable_branding)) {
            throw new \InvalidArgumentException('non-nullable disable_branding cannot be null');
        }
        $this->container['disable_branding'] = $disable_branding;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


