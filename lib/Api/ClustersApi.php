<?php
/**
 * ClustersApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Nutanix Intentful API
 *
 * Move programming from the user to the machine.
 *
 * The version of the OpenAPI document: 3.1.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ClustersApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ClustersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'clustersEntityReplicationTargetDetailsPost' => [
            'application/json',
        ],
        'clustersListPost' => [
            'application/json',
        ],
        'clustersMulticlusterConfigClusterUuidMigrateSspConfigPost' => [
            'application/json',
        ],
        'clustersMulticlusterConfigPost' => [
            'application/json',
        ],
        'clustersMulticlusterConfigUuidCancelPost' => [
            'application/json',
        ],
        'clustersMulticlusterConfigUuidDelete' => [
            'application/json',
        ],
        'clustersMulticlusterConfigUuidPausePost' => [
            'application/json',
        ],
        'clustersMulticlusterConfigUuidPut' => [
            'application/json',
        ],
        'clustersMulticlusterConfigUuidResumePost' => [
            'application/json',
        ],
        'clustersRecoveryPointResourceReservationPost' => [
            'application/json',
        ],
        'clustersSynchronousReplicationCapablePost' => [
            'application/json',
        ],
        'clustersUuidCertificatesCaCertsCaNameDelete' => [
            'application/json',
        ],
        'clustersUuidCertificatesCaCertsPost' => [
            'application/json',
        ],
        'clustersUuidCertificatesClientAuthDelete' => [
            'application/json',
        ],
        'clustersUuidCertificatesClientAuthPost' => [
            'application/json',
        ],
        'clustersUuidCertificatesClientAuthPut' => [
            'application/json',
        ],
        'clustersUuidCertificatesCsrsGet' => [
            'application/json',
        ],
        'clustersUuidCertificatesCsrsNodeIpGet' => [
            'application/json',
        ],
        'clustersUuidCertificatesPemkeyImportPost' => [
            'application/json',
        ],
        'clustersUuidCertificatesPemkeyPost' => [
            'application/json',
        ],
        'clustersUuidCertificatesRootDelete' => [
            'application/json',
        ],
        'clustersUuidCertificatesRootGet' => [
            'application/json',
        ],
        'clustersUuidCertificatesRootPost' => [
            'application/json',
        ],
        'clustersUuidCertificatesSvmCertsKmsUuidPost' => [
            'application/json',
        ],
        'clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete' => [
            'application/json',
        ],
        'clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut' => [
            'application/json',
        ],
        'clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete' => [
            'application/json',
        ],
        'clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet' => [
            'application/json',
        ],
        'clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut' => [
            'application/json',
        ],
        'clustersUuidCloudCredentialsCloudTypeDelete' => [
            'application/json',
        ],
        'clustersUuidCloudCredentialsCloudTypeListPost' => [
            'application/json',
        ],
        'clustersUuidCloudCredentialsCloudTypePost' => [
            'application/json',
        ],
        'clustersUuidGet' => [
            'application/json',
        ],
        'clustersUuidPut' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation clustersEntityReplicationTargetDetailsPost
     *
     * Get the placement information for an entity. This will be used to identify the replication target for an entity snapshot or placement of the entity.
     *
     * @param  \OpenAPI\Client\Model\PlacementSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersEntityReplicationTargetDetailsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PlacementDetail
     */
    public function clustersEntityReplicationTargetDetailsPost($spec, string $contentType = self::contentTypes['clustersEntityReplicationTargetDetailsPost'][0])
    {
        list($response) = $this->clustersEntityReplicationTargetDetailsPostWithHttpInfo($spec, $contentType);
        return $response;
    }

    /**
     * Operation clustersEntityReplicationTargetDetailsPostWithHttpInfo
     *
     * Get the placement information for an entity. This will be used to identify the replication target for an entity snapshot or placement of the entity.
     *
     * @param  \OpenAPI\Client\Model\PlacementSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersEntityReplicationTargetDetailsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PlacementDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersEntityReplicationTargetDetailsPostWithHttpInfo($spec, string $contentType = self::contentTypes['clustersEntityReplicationTargetDetailsPost'][0])
    {
        $request = $this->clustersEntityReplicationTargetDetailsPostRequest($spec, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PlacementDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PlacementDetail' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PlacementDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PlacementDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PlacementDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersEntityReplicationTargetDetailsPostAsync
     *
     * Get the placement information for an entity. This will be used to identify the replication target for an entity snapshot or placement of the entity.
     *
     * @param  \OpenAPI\Client\Model\PlacementSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersEntityReplicationTargetDetailsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersEntityReplicationTargetDetailsPostAsync($spec, string $contentType = self::contentTypes['clustersEntityReplicationTargetDetailsPost'][0])
    {
        return $this->clustersEntityReplicationTargetDetailsPostAsyncWithHttpInfo($spec, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersEntityReplicationTargetDetailsPostAsyncWithHttpInfo
     *
     * Get the placement information for an entity. This will be used to identify the replication target for an entity snapshot or placement of the entity.
     *
     * @param  \OpenAPI\Client\Model\PlacementSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersEntityReplicationTargetDetailsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersEntityReplicationTargetDetailsPostAsyncWithHttpInfo($spec, string $contentType = self::contentTypes['clustersEntityReplicationTargetDetailsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PlacementDetail';
        $request = $this->clustersEntityReplicationTargetDetailsPostRequest($spec, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersEntityReplicationTargetDetailsPost'
     *
     * @param  \OpenAPI\Client\Model\PlacementSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersEntityReplicationTargetDetailsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersEntityReplicationTargetDetailsPostRequest($spec, string $contentType = self::contentTypes['clustersEntityReplicationTargetDetailsPost'][0])
    {

        // verify the required parameter 'spec' is set
        if ($spec === null || (is_array($spec) && count($spec) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $spec when calling clustersEntityReplicationTargetDetailsPost'
            );
        }


        $resourcePath = '/clusters/entity_replication_target_details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($spec)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($spec));
            } else {
                $httpBody = $spec;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersListPost
     *
     * Get a list of existing clusters
     *
     * @param  \OpenAPI\Client\Model\ClusterListMetadata $get_entities_request get_entities_request (required)
     * @param  string $force_refresh Forcefully get the latest response. (Values can be True, False) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersListPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ClusterListIntentResponse|\OpenAPI\Client\Model\ClusterStatus
     */
    public function clustersListPost($get_entities_request, $force_refresh = null, string $contentType = self::contentTypes['clustersListPost'][0])
    {
        list($response) = $this->clustersListPostWithHttpInfo($get_entities_request, $force_refresh, $contentType);
        return $response;
    }

    /**
     * Operation clustersListPostWithHttpInfo
     *
     * Get a list of existing clusters
     *
     * @param  \OpenAPI\Client\Model\ClusterListMetadata $get_entities_request (required)
     * @param  string $force_refresh Forcefully get the latest response. (Values can be True, False) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersListPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ClusterListIntentResponse|\OpenAPI\Client\Model\ClusterStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersListPostWithHttpInfo($get_entities_request, $force_refresh = null, string $contentType = self::contentTypes['clustersListPost'][0])
    {
        $request = $this->clustersListPostRequest($get_entities_request, $force_refresh, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ClusterListIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClusterListIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClusterListIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ClusterStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClusterStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClusterStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ClusterListIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClusterListIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClusterStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersListPostAsync
     *
     * Get a list of existing clusters
     *
     * @param  \OpenAPI\Client\Model\ClusterListMetadata $get_entities_request (required)
     * @param  string $force_refresh Forcefully get the latest response. (Values can be True, False) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersListPostAsync($get_entities_request, $force_refresh = null, string $contentType = self::contentTypes['clustersListPost'][0])
    {
        return $this->clustersListPostAsyncWithHttpInfo($get_entities_request, $force_refresh, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersListPostAsyncWithHttpInfo
     *
     * Get a list of existing clusters
     *
     * @param  \OpenAPI\Client\Model\ClusterListMetadata $get_entities_request (required)
     * @param  string $force_refresh Forcefully get the latest response. (Values can be True, False) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersListPostAsyncWithHttpInfo($get_entities_request, $force_refresh = null, string $contentType = self::contentTypes['clustersListPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ClusterListIntentResponse';
        $request = $this->clustersListPostRequest($get_entities_request, $force_refresh, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersListPost'
     *
     * @param  \OpenAPI\Client\Model\ClusterListMetadata $get_entities_request (required)
     * @param  string $force_refresh Forcefully get the latest response. (Values can be True, False) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersListPostRequest($get_entities_request, $force_refresh = null, string $contentType = self::contentTypes['clustersListPost'][0])
    {

        // verify the required parameter 'get_entities_request' is set
        if ($get_entities_request === null || (is_array($get_entities_request) && count($get_entities_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $get_entities_request when calling clustersListPost'
            );
        }



        $resourcePath = '/clusters/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($force_refresh !== null) {
            $headerParams['Force-Refresh'] = ObjectSerializer::toHeaderValue($force_refresh);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($get_entities_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($get_entities_request));
            } else {
                $httpBody = $get_entities_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersMulticlusterConfigClusterUuidMigrateSspConfigPost
     *
     * Migrate SSP config from a Prism Element.
     *
     * @param  string $cluster_uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\SspConfigInput $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SspMigrationStatus
     */
    public function clustersMulticlusterConfigClusterUuidMigrateSspConfigPost($cluster_uuid, $body = null, string $contentType = self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'][0])
    {
        list($response) = $this->clustersMulticlusterConfigClusterUuidMigrateSspConfigPostWithHttpInfo($cluster_uuid, $body, $contentType);
        return $response;
    }

    /**
     * Operation clustersMulticlusterConfigClusterUuidMigrateSspConfigPostWithHttpInfo
     *
     * Migrate SSP config from a Prism Element.
     *
     * @param  string $cluster_uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\SspConfigInput $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SspMigrationStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersMulticlusterConfigClusterUuidMigrateSspConfigPostWithHttpInfo($cluster_uuid, $body = null, string $contentType = self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'][0])
    {
        $request = $this->clustersMulticlusterConfigClusterUuidMigrateSspConfigPostRequest($cluster_uuid, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\SspMigrationStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SspMigrationStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SspMigrationStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SspMigrationStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SspMigrationStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersMulticlusterConfigClusterUuidMigrateSspConfigPostAsync
     *
     * Migrate SSP config from a Prism Element.
     *
     * @param  string $cluster_uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\SspConfigInput $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigClusterUuidMigrateSspConfigPostAsync($cluster_uuid, $body = null, string $contentType = self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'][0])
    {
        return $this->clustersMulticlusterConfigClusterUuidMigrateSspConfigPostAsyncWithHttpInfo($cluster_uuid, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersMulticlusterConfigClusterUuidMigrateSspConfigPostAsyncWithHttpInfo
     *
     * Migrate SSP config from a Prism Element.
     *
     * @param  string $cluster_uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\SspConfigInput $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigClusterUuidMigrateSspConfigPostAsyncWithHttpInfo($cluster_uuid, $body = null, string $contentType = self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SspMigrationStatus';
        $request = $this->clustersMulticlusterConfigClusterUuidMigrateSspConfigPostRequest($cluster_uuid, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'
     *
     * @param  string $cluster_uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\SspConfigInput $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersMulticlusterConfigClusterUuidMigrateSspConfigPostRequest($cluster_uuid, $body = null, string $contentType = self::contentTypes['clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'][0])
    {

        // verify the required parameter 'cluster_uuid' is set
        if ($cluster_uuid === null || (is_array($cluster_uuid) && count($cluster_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_uuid when calling clustersMulticlusterConfigClusterUuidMigrateSspConfigPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $cluster_uuid)) {
            throw new \InvalidArgumentException("invalid value for \"cluster_uuid\" when calling ClustersApi.clustersMulticlusterConfigClusterUuidMigrateSspConfigPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        


        $resourcePath = '/clusters/multicluster_config/{cluster_uuid}/migrate_ssp_config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_uuid' . '}',
                ObjectSerializer::toPathValue($cluster_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersMulticlusterConfigPost
     *
     * Apply multicluster configuration from Prism Central.
     *
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MulticlusterConfigIntentResponse|\OpenAPI\Client\Model\MulticlusterConfigStatus
     */
    public function clustersMulticlusterConfigPost($body, string $contentType = self::contentTypes['clustersMulticlusterConfigPost'][0])
    {
        list($response) = $this->clustersMulticlusterConfigPostWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation clustersMulticlusterConfigPostWithHttpInfo
     *
     * Apply multicluster configuration from Prism Central.
     *
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MulticlusterConfigIntentResponse|\OpenAPI\Client\Model\MulticlusterConfigStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersMulticlusterConfigPostWithHttpInfo($body, string $contentType = self::contentTypes['clustersMulticlusterConfigPost'][0])
    {
        $request = $this->clustersMulticlusterConfigPostRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\MulticlusterConfigIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MulticlusterConfigIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\MulticlusterConfigStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MulticlusterConfigStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MulticlusterConfigStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MulticlusterConfigStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersMulticlusterConfigPostAsync
     *
     * Apply multicluster configuration from Prism Central.
     *
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigPostAsync($body, string $contentType = self::contentTypes['clustersMulticlusterConfigPost'][0])
    {
        return $this->clustersMulticlusterConfigPostAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersMulticlusterConfigPostAsyncWithHttpInfo
     *
     * Apply multicluster configuration from Prism Central.
     *
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigPostAsyncWithHttpInfo($body, string $contentType = self::contentTypes['clustersMulticlusterConfigPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse';
        $request = $this->clustersMulticlusterConfigPostRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersMulticlusterConfigPost'
     *
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersMulticlusterConfigPostRequest($body, string $contentType = self::contentTypes['clustersMulticlusterConfigPost'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clustersMulticlusterConfigPost'
            );
        }


        $resourcePath = '/clusters/multicluster_config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersMulticlusterConfigUuidCancelPost
     *
     * Cancel a multicluster configuration request from Prism Central.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidCancelPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersMulticlusterConfigUuidCancelPost($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidCancelPost'][0])
    {
        $this->clustersMulticlusterConfigUuidCancelPostWithHttpInfo($uuid, $contentType);
    }

    /**
     * Operation clustersMulticlusterConfigUuidCancelPostWithHttpInfo
     *
     * Cancel a multicluster configuration request from Prism Central.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidCancelPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersMulticlusterConfigUuidCancelPostWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidCancelPost'][0])
    {
        $request = $this->clustersMulticlusterConfigUuidCancelPostRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersMulticlusterConfigUuidCancelPostAsync
     *
     * Cancel a multicluster configuration request from Prism Central.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidCancelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidCancelPostAsync($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidCancelPost'][0])
    {
        return $this->clustersMulticlusterConfigUuidCancelPostAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersMulticlusterConfigUuidCancelPostAsyncWithHttpInfo
     *
     * Cancel a multicluster configuration request from Prism Central.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidCancelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidCancelPostAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidCancelPost'][0])
    {
        $returnType = '';
        $request = $this->clustersMulticlusterConfigUuidCancelPostRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersMulticlusterConfigUuidCancelPost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidCancelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersMulticlusterConfigUuidCancelPostRequest($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidCancelPost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersMulticlusterConfigUuidCancelPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersMulticlusterConfigUuidCancelPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/multicluster_config/{uuid}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersMulticlusterConfigUuidDelete
     *
     * Delete a scheduled and unprocessed multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MulticlusterConfigIntentResponse|\OpenAPI\Client\Model\MulticlusterConfigStatus
     */
    public function clustersMulticlusterConfigUuidDelete($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidDelete'][0])
    {
        list($response) = $this->clustersMulticlusterConfigUuidDeleteWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation clustersMulticlusterConfigUuidDeleteWithHttpInfo
     *
     * Delete a scheduled and unprocessed multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MulticlusterConfigIntentResponse|\OpenAPI\Client\Model\MulticlusterConfigStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersMulticlusterConfigUuidDeleteWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidDelete'][0])
    {
        $request = $this->clustersMulticlusterConfigUuidDeleteRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\MulticlusterConfigIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MulticlusterConfigIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\MulticlusterConfigStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MulticlusterConfigStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MulticlusterConfigStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MulticlusterConfigStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersMulticlusterConfigUuidDeleteAsync
     *
     * Delete a scheduled and unprocessed multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidDeleteAsync($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidDelete'][0])
    {
        return $this->clustersMulticlusterConfigUuidDeleteAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersMulticlusterConfigUuidDeleteAsyncWithHttpInfo
     *
     * Delete a scheduled and unprocessed multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidDeleteAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse';
        $request = $this->clustersMulticlusterConfigUuidDeleteRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersMulticlusterConfigUuidDelete'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersMulticlusterConfigUuidDeleteRequest($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidDelete'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersMulticlusterConfigUuidDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersMulticlusterConfigUuidDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/multicluster_config/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersMulticlusterConfigUuidPausePost
     *
     * Pause a multicluster configuration request from Prism Central.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPausePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersMulticlusterConfigUuidPausePost($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPausePost'][0])
    {
        $this->clustersMulticlusterConfigUuidPausePostWithHttpInfo($uuid, $contentType);
    }

    /**
     * Operation clustersMulticlusterConfigUuidPausePostWithHttpInfo
     *
     * Pause a multicluster configuration request from Prism Central.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPausePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersMulticlusterConfigUuidPausePostWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPausePost'][0])
    {
        $request = $this->clustersMulticlusterConfigUuidPausePostRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersMulticlusterConfigUuidPausePostAsync
     *
     * Pause a multicluster configuration request from Prism Central.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPausePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidPausePostAsync($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPausePost'][0])
    {
        return $this->clustersMulticlusterConfigUuidPausePostAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersMulticlusterConfigUuidPausePostAsyncWithHttpInfo
     *
     * Pause a multicluster configuration request from Prism Central.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPausePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidPausePostAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPausePost'][0])
    {
        $returnType = '';
        $request = $this->clustersMulticlusterConfigUuidPausePostRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersMulticlusterConfigUuidPausePost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPausePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersMulticlusterConfigUuidPausePostRequest($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPausePost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersMulticlusterConfigUuidPausePost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersMulticlusterConfigUuidPausePost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/multicluster_config/{uuid}/pause';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersMulticlusterConfigUuidPut
     *
     * Update a scheduled and unprocessed multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MulticlusterConfigIntentResponse|\OpenAPI\Client\Model\MulticlusterConfigStatus
     */
    public function clustersMulticlusterConfigUuidPut($uuid, $body, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPut'][0])
    {
        list($response) = $this->clustersMulticlusterConfigUuidPutWithHttpInfo($uuid, $body, $contentType);
        return $response;
    }

    /**
     * Operation clustersMulticlusterConfigUuidPutWithHttpInfo
     *
     * Update a scheduled and unprocessed multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MulticlusterConfigIntentResponse|\OpenAPI\Client\Model\MulticlusterConfigStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersMulticlusterConfigUuidPutWithHttpInfo($uuid, $body, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPut'][0])
    {
        $request = $this->clustersMulticlusterConfigUuidPutRequest($uuid, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\MulticlusterConfigIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MulticlusterConfigIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\MulticlusterConfigStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MulticlusterConfigStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MulticlusterConfigStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MulticlusterConfigStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersMulticlusterConfigUuidPutAsync
     *
     * Update a scheduled and unprocessed multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidPutAsync($uuid, $body, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPut'][0])
    {
        return $this->clustersMulticlusterConfigUuidPutAsyncWithHttpInfo($uuid, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersMulticlusterConfigUuidPutAsyncWithHttpInfo
     *
     * Update a scheduled and unprocessed multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidPutAsyncWithHttpInfo($uuid, $body, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPut'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MulticlusterConfigIntentResponse';
        $request = $this->clustersMulticlusterConfigUuidPutRequest($uuid, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersMulticlusterConfigUuidPut'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\MulticlusterConfigIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersMulticlusterConfigUuidPutRequest($uuid, $body, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidPut'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersMulticlusterConfigUuidPut'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersMulticlusterConfigUuidPut, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clustersMulticlusterConfigUuidPut'
            );
        }


        $resourcePath = '/clusters/multicluster_config/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersMulticlusterConfigUuidResumePost
     *
     * Resume a paused multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidResumePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersMulticlusterConfigUuidResumePost($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidResumePost'][0])
    {
        $this->clustersMulticlusterConfigUuidResumePostWithHttpInfo($uuid, $contentType);
    }

    /**
     * Operation clustersMulticlusterConfigUuidResumePostWithHttpInfo
     *
     * Resume a paused multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidResumePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersMulticlusterConfigUuidResumePostWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidResumePost'][0])
    {
        $request = $this->clustersMulticlusterConfigUuidResumePostRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersMulticlusterConfigUuidResumePostAsync
     *
     * Resume a paused multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidResumePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidResumePostAsync($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidResumePost'][0])
    {
        return $this->clustersMulticlusterConfigUuidResumePostAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersMulticlusterConfigUuidResumePostAsyncWithHttpInfo
     *
     * Resume a paused multicluster configuration request.
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidResumePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersMulticlusterConfigUuidResumePostAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidResumePost'][0])
    {
        $returnType = '';
        $request = $this->clustersMulticlusterConfigUuidResumePostRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersMulticlusterConfigUuidResumePost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersMulticlusterConfigUuidResumePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersMulticlusterConfigUuidResumePostRequest($uuid, string $contentType = self::contentTypes['clustersMulticlusterConfigUuidResumePost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersMulticlusterConfigUuidResumePost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersMulticlusterConfigUuidResumePost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/multicluster_config/{uuid}/resume';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersRecoveryPointResourceReservationPost
     *
     * Update the Lazan resource reservation lease for the given recovery point replication.
     *
     * @param  \OpenAPI\Client\Model\RecoveryPointResourceReservationSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersRecoveryPointResourceReservationPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersRecoveryPointResourceReservationPost($spec, string $contentType = self::contentTypes['clustersRecoveryPointResourceReservationPost'][0])
    {
        $this->clustersRecoveryPointResourceReservationPostWithHttpInfo($spec, $contentType);
    }

    /**
     * Operation clustersRecoveryPointResourceReservationPostWithHttpInfo
     *
     * Update the Lazan resource reservation lease for the given recovery point replication.
     *
     * @param  \OpenAPI\Client\Model\RecoveryPointResourceReservationSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersRecoveryPointResourceReservationPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersRecoveryPointResourceReservationPostWithHttpInfo($spec, string $contentType = self::contentTypes['clustersRecoveryPointResourceReservationPost'][0])
    {
        $request = $this->clustersRecoveryPointResourceReservationPostRequest($spec, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersRecoveryPointResourceReservationPostAsync
     *
     * Update the Lazan resource reservation lease for the given recovery point replication.
     *
     * @param  \OpenAPI\Client\Model\RecoveryPointResourceReservationSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersRecoveryPointResourceReservationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersRecoveryPointResourceReservationPostAsync($spec, string $contentType = self::contentTypes['clustersRecoveryPointResourceReservationPost'][0])
    {
        return $this->clustersRecoveryPointResourceReservationPostAsyncWithHttpInfo($spec, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersRecoveryPointResourceReservationPostAsyncWithHttpInfo
     *
     * Update the Lazan resource reservation lease for the given recovery point replication.
     *
     * @param  \OpenAPI\Client\Model\RecoveryPointResourceReservationSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersRecoveryPointResourceReservationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersRecoveryPointResourceReservationPostAsyncWithHttpInfo($spec, string $contentType = self::contentTypes['clustersRecoveryPointResourceReservationPost'][0])
    {
        $returnType = '';
        $request = $this->clustersRecoveryPointResourceReservationPostRequest($spec, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersRecoveryPointResourceReservationPost'
     *
     * @param  \OpenAPI\Client\Model\RecoveryPointResourceReservationSpec $spec Entity spec. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersRecoveryPointResourceReservationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersRecoveryPointResourceReservationPostRequest($spec, string $contentType = self::contentTypes['clustersRecoveryPointResourceReservationPost'][0])
    {

        // verify the required parameter 'spec' is set
        if ($spec === null || (is_array($spec) && count($spec) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $spec when calling clustersRecoveryPointResourceReservationPost'
            );
        }


        $resourcePath = '/clusters/recovery_point_resource_reservation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($spec)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($spec));
            } else {
                $httpBody = $spec;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersSynchronousReplicationCapablePost
     *
     * Get a list of existing clusters
     *
     * @param  \OpenAPI\Client\Model\ClusterSynchronousReplicationCapableInput $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersSynchronousReplicationCapablePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ClusterSynchronousReplicationCapableResponseInner[]|\OpenAPI\Client\Model\ClusterStatus
     */
    public function clustersSynchronousReplicationCapablePost($body, string $contentType = self::contentTypes['clustersSynchronousReplicationCapablePost'][0])
    {
        list($response) = $this->clustersSynchronousReplicationCapablePostWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation clustersSynchronousReplicationCapablePostWithHttpInfo
     *
     * Get a list of existing clusters
     *
     * @param  \OpenAPI\Client\Model\ClusterSynchronousReplicationCapableInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersSynchronousReplicationCapablePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ClusterSynchronousReplicationCapableResponseInner[]|\OpenAPI\Client\Model\ClusterStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersSynchronousReplicationCapablePostWithHttpInfo($body, string $contentType = self::contentTypes['clustersSynchronousReplicationCapablePost'][0])
    {
        $request = $this->clustersSynchronousReplicationCapablePostRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ClusterSynchronousReplicationCapableResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClusterSynchronousReplicationCapableResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClusterSynchronousReplicationCapableResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ClusterStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClusterStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClusterStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ClusterSynchronousReplicationCapableResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClusterSynchronousReplicationCapableResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClusterStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersSynchronousReplicationCapablePostAsync
     *
     * Get a list of existing clusters
     *
     * @param  \OpenAPI\Client\Model\ClusterSynchronousReplicationCapableInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersSynchronousReplicationCapablePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersSynchronousReplicationCapablePostAsync($body, string $contentType = self::contentTypes['clustersSynchronousReplicationCapablePost'][0])
    {
        return $this->clustersSynchronousReplicationCapablePostAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersSynchronousReplicationCapablePostAsyncWithHttpInfo
     *
     * Get a list of existing clusters
     *
     * @param  \OpenAPI\Client\Model\ClusterSynchronousReplicationCapableInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersSynchronousReplicationCapablePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersSynchronousReplicationCapablePostAsyncWithHttpInfo($body, string $contentType = self::contentTypes['clustersSynchronousReplicationCapablePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ClusterSynchronousReplicationCapableResponseInner[]';
        $request = $this->clustersSynchronousReplicationCapablePostRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersSynchronousReplicationCapablePost'
     *
     * @param  \OpenAPI\Client\Model\ClusterSynchronousReplicationCapableInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersSynchronousReplicationCapablePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersSynchronousReplicationCapablePostRequest($body, string $contentType = self::contentTypes['clustersSynchronousReplicationCapablePost'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clustersSynchronousReplicationCapablePost'
            );
        }


        $resourcePath = '/clusters/synchronous_replication_capable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesCaCertsCaNameDelete
     *
     * Delete the CA certificate
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $ca_name ca_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesCaCertsCaNameDelete($uuid, $ca_name, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'][0])
    {
        $this->clustersUuidCertificatesCaCertsCaNameDeleteWithHttpInfo($uuid, $ca_name, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesCaCertsCaNameDeleteWithHttpInfo
     *
     * Delete the CA certificate
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $ca_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesCaCertsCaNameDeleteWithHttpInfo($uuid, $ca_name, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'][0])
    {
        $request = $this->clustersUuidCertificatesCaCertsCaNameDeleteRequest($uuid, $ca_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesCaCertsCaNameDeleteAsync
     *
     * Delete the CA certificate
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $ca_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesCaCertsCaNameDeleteAsync($uuid, $ca_name, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'][0])
    {
        return $this->clustersUuidCertificatesCaCertsCaNameDeleteAsyncWithHttpInfo($uuid, $ca_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesCaCertsCaNameDeleteAsyncWithHttpInfo
     *
     * Delete the CA certificate
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $ca_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesCaCertsCaNameDeleteAsyncWithHttpInfo($uuid, $ca_name, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesCaCertsCaNameDeleteRequest($uuid, $ca_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesCaCertsCaNameDelete'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $ca_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesCaCertsCaNameDeleteRequest($uuid, $ca_name, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsCaNameDelete'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesCaCertsCaNameDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesCaCertsCaNameDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'ca_name' is set
        if ($ca_name === null || (is_array($ca_name) && count($ca_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ca_name when calling clustersUuidCertificatesCaCertsCaNameDelete'
            );
        }
        if (strlen($ca_name) > 64) {
            throw new \InvalidArgumentException('invalid length for "$ca_name" when calling ClustersApi.clustersUuidCertificatesCaCertsCaNameDelete, must be smaller than or equal to 64.');
        }
        

        $resourcePath = '/clusters/{uuid}/certificates/ca_certs/{ca_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($ca_name !== null) {
            $resourcePath = str_replace(
                '{' . 'ca_name' . '}',
                ObjectSerializer::toPathValue($ca_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesCaCertsPost
     *
     * Add a new CA certificate
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaCert $spec spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesCaCertsPost($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsPost'][0])
    {
        $this->clustersUuidCertificatesCaCertsPostWithHttpInfo($uuid, $spec, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesCaCertsPostWithHttpInfo
     *
     * Add a new CA certificate
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaCert $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesCaCertsPostWithHttpInfo($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsPost'][0])
    {
        $request = $this->clustersUuidCertificatesCaCertsPostRequest($uuid, $spec, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesCaCertsPostAsync
     *
     * Add a new CA certificate
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaCert $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesCaCertsPostAsync($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsPost'][0])
    {
        return $this->clustersUuidCertificatesCaCertsPostAsyncWithHttpInfo($uuid, $spec, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesCaCertsPostAsyncWithHttpInfo
     *
     * Add a new CA certificate
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaCert $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesCaCertsPostAsyncWithHttpInfo($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsPost'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesCaCertsPostRequest($uuid, $spec, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesCaCertsPost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaCert $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCaCertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesCaCertsPostRequest($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesCaCertsPost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesCaCertsPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesCaCertsPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'spec' is set
        if ($spec === null || (is_array($spec) && count($spec) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $spec when calling clustersUuidCertificatesCaCertsPost'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/ca_certs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($spec)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($spec));
            } else {
                $httpBody = $spec;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesClientAuthDelete
     *
     * Remove the CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesClientAuthDelete($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthDelete'][0])
    {
        $this->clustersUuidCertificatesClientAuthDeleteWithHttpInfo($uuid, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesClientAuthDeleteWithHttpInfo
     *
     * Remove the CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesClientAuthDeleteWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthDelete'][0])
    {
        $request = $this->clustersUuidCertificatesClientAuthDeleteRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesClientAuthDeleteAsync
     *
     * Remove the CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesClientAuthDeleteAsync($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthDelete'][0])
    {
        return $this->clustersUuidCertificatesClientAuthDeleteAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesClientAuthDeleteAsyncWithHttpInfo
     *
     * Remove the CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesClientAuthDeleteAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthDelete'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesClientAuthDeleteRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesClientAuthDelete'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesClientAuthDeleteRequest($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthDelete'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesClientAuthDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesClientAuthDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/{uuid}/certificates/client_auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesClientAuthPost
     *
     * Import CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesClientAuthPost($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPost'][0])
    {
        $this->clustersUuidCertificatesClientAuthPostWithHttpInfo($uuid, $spec, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesClientAuthPostWithHttpInfo
     *
     * Import CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesClientAuthPostWithHttpInfo($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPost'][0])
    {
        $request = $this->clustersUuidCertificatesClientAuthPostRequest($uuid, $spec, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesClientAuthPostAsync
     *
     * Import CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesClientAuthPostAsync($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPost'][0])
    {
        return $this->clustersUuidCertificatesClientAuthPostAsyncWithHttpInfo($uuid, $spec, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesClientAuthPostAsyncWithHttpInfo
     *
     * Import CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesClientAuthPostAsyncWithHttpInfo($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPost'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesClientAuthPostRequest($uuid, $spec, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesClientAuthPost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesClientAuthPostRequest($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesClientAuthPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesClientAuthPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'spec' is set
        if ($spec === null || (is_array($spec) && count($spec) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $spec when calling clustersUuidCertificatesClientAuthPost'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/client_auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($spec)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($spec));
            } else {
                $httpBody = $spec;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesClientAuthPut
     *
     * Replace the CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesClientAuthPut($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPut'][0])
    {
        $this->clustersUuidCertificatesClientAuthPutWithHttpInfo($uuid, $spec, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesClientAuthPutWithHttpInfo
     *
     * Replace the CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesClientAuthPutWithHttpInfo($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPut'][0])
    {
        $request = $this->clustersUuidCertificatesClientAuthPutRequest($uuid, $spec, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesClientAuthPutAsync
     *
     * Replace the CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesClientAuthPutAsync($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPut'][0])
    {
        return $this->clustersUuidCertificatesClientAuthPutAsyncWithHttpInfo($uuid, $spec, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesClientAuthPutAsyncWithHttpInfo
     *
     * Replace the CA chain for client authentication
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesClientAuthPutAsyncWithHttpInfo($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPut'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesClientAuthPutRequest($uuid, $spec, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesClientAuthPut'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CaChainSpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesClientAuthPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesClientAuthPutRequest($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesClientAuthPut'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesClientAuthPut'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesClientAuthPut, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'spec' is set
        if ($spec === null || (is_array($spec) && count($spec) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $spec when calling clustersUuidCertificatesClientAuthPut'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/client_auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($spec)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($spec));
            } else {
                $httpBody = $spec;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesCsrsGet
     *
     * Download CSRs from cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CsrsSpec $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesCsrsGet($uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsGet'][0])
    {
        $this->clustersUuidCertificatesCsrsGetWithHttpInfo($uuid, $body, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesCsrsGetWithHttpInfo
     *
     * Download CSRs from cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CsrsSpec $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesCsrsGetWithHttpInfo($uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsGet'][0])
    {
        $request = $this->clustersUuidCertificatesCsrsGetRequest($uuid, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesCsrsGetAsync
     *
     * Download CSRs from cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CsrsSpec $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesCsrsGetAsync($uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsGet'][0])
    {
        return $this->clustersUuidCertificatesCsrsGetAsyncWithHttpInfo($uuid, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesCsrsGetAsyncWithHttpInfo
     *
     * Download CSRs from cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CsrsSpec $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesCsrsGetAsyncWithHttpInfo($uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsGet'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesCsrsGetRequest($uuid, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesCsrsGet'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\CsrsSpec $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesCsrsGetRequest($uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesCsrsGet'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesCsrsGet, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clustersUuidCertificatesCsrsGet'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/csrs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesCsrsNodeIpGet
     *
     * Download CSR from a discovered node
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_ip node_ip (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesCsrsNodeIpGet($uuid, $node_ip, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'][0])
    {
        $this->clustersUuidCertificatesCsrsNodeIpGetWithHttpInfo($uuid, $node_ip, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesCsrsNodeIpGetWithHttpInfo
     *
     * Download CSR from a discovered node
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_ip (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesCsrsNodeIpGetWithHttpInfo($uuid, $node_ip, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'][0])
    {
        $request = $this->clustersUuidCertificatesCsrsNodeIpGetRequest($uuid, $node_ip, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesCsrsNodeIpGetAsync
     *
     * Download CSR from a discovered node
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_ip (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesCsrsNodeIpGetAsync($uuid, $node_ip, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'][0])
    {
        return $this->clustersUuidCertificatesCsrsNodeIpGetAsyncWithHttpInfo($uuid, $node_ip, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesCsrsNodeIpGetAsyncWithHttpInfo
     *
     * Download CSR from a discovered node
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_ip (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesCsrsNodeIpGetAsyncWithHttpInfo($uuid, $node_ip, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesCsrsNodeIpGetRequest($uuid, $node_ip, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesCsrsNodeIpGet'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_ip (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesCsrsNodeIpGetRequest($uuid, $node_ip, string $contentType = self::contentTypes['clustersUuidCertificatesCsrsNodeIpGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesCsrsNodeIpGet'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesCsrsNodeIpGet, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'node_ip' is set
        if ($node_ip === null || (is_array($node_ip) && count($node_ip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node_ip when calling clustersUuidCertificatesCsrsNodeIpGet'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/csrs/{node_ip}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($node_ip !== null) {
            $resourcePath = str_replace(
                '{' . 'node_ip' . '}',
                ObjectSerializer::toPathValue($node_ip),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesPemkeyImportPost
     *
     * Import a new key
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\PemkeySpec $spec spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyImportPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesPemkeyImportPost($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyImportPost'][0])
    {
        $this->clustersUuidCertificatesPemkeyImportPostWithHttpInfo($uuid, $spec, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesPemkeyImportPostWithHttpInfo
     *
     * Import a new key
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\PemkeySpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyImportPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesPemkeyImportPostWithHttpInfo($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyImportPost'][0])
    {
        $request = $this->clustersUuidCertificatesPemkeyImportPostRequest($uuid, $spec, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesPemkeyImportPostAsync
     *
     * Import a new key
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\PemkeySpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesPemkeyImportPostAsync($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyImportPost'][0])
    {
        return $this->clustersUuidCertificatesPemkeyImportPostAsyncWithHttpInfo($uuid, $spec, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesPemkeyImportPostAsyncWithHttpInfo
     *
     * Import a new key
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\PemkeySpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesPemkeyImportPostAsyncWithHttpInfo($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyImportPost'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesPemkeyImportPostRequest($uuid, $spec, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesPemkeyImportPost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\PemkeySpec $spec (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesPemkeyImportPostRequest($uuid, $spec, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyImportPost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesPemkeyImportPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesPemkeyImportPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'spec' is set
        if ($spec === null || (is_array($spec) && count($spec) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $spec when calling clustersUuidCertificatesPemkeyImportPost'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/pemkey/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($spec)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($spec));
            } else {
                $httpBody = $spec;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesPemkeyPost
     *
     * Generate a 2048 bits cipher length RSA key
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesPemkeyPost($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyPost'][0])
    {
        $this->clustersUuidCertificatesPemkeyPostWithHttpInfo($uuid, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesPemkeyPostWithHttpInfo
     *
     * Generate a 2048 bits cipher length RSA key
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesPemkeyPostWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyPost'][0])
    {
        $request = $this->clustersUuidCertificatesPemkeyPostRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesPemkeyPostAsync
     *
     * Generate a 2048 bits cipher length RSA key
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesPemkeyPostAsync($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyPost'][0])
    {
        return $this->clustersUuidCertificatesPemkeyPostAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesPemkeyPostAsyncWithHttpInfo
     *
     * Generate a 2048 bits cipher length RSA key
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesPemkeyPostAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyPost'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesPemkeyPostRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesPemkeyPost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesPemkeyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesPemkeyPostRequest($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesPemkeyPost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesPemkeyPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesPemkeyPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/{uuid}/certificates/pemkey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesRootDelete
     *
     * Remove PC root certificates
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesRootDelete($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootDelete'][0])
    {
        $this->clustersUuidCertificatesRootDeleteWithHttpInfo($uuid, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesRootDeleteWithHttpInfo
     *
     * Remove PC root certificates
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesRootDeleteWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootDelete'][0])
    {
        $request = $this->clustersUuidCertificatesRootDeleteRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesRootDeleteAsync
     *
     * Remove PC root certificates
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesRootDeleteAsync($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootDelete'][0])
    {
        return $this->clustersUuidCertificatesRootDeleteAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesRootDeleteAsyncWithHttpInfo
     *
     * Remove PC root certificates
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesRootDeleteAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootDelete'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesRootDeleteRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesRootDelete'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesRootDeleteRequest($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootDelete'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesRootDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesRootDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/{uuid}/certificates/root';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesRootGet
     *
     * Retrieve PC root certificates
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Certificate
     */
    public function clustersUuidCertificatesRootGet($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootGet'][0])
    {
        list($response) = $this->clustersUuidCertificatesRootGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidCertificatesRootGetWithHttpInfo
     *
     * Retrieve PC root certificates
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Certificate, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesRootGetWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootGet'][0])
    {
        $request = $this->clustersUuidCertificatesRootGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Certificate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Certificate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Certificate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Certificate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Certificate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesRootGetAsync
     *
     * Retrieve PC root certificates
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesRootGetAsync($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootGet'][0])
    {
        return $this->clustersUuidCertificatesRootGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesRootGetAsyncWithHttpInfo
     *
     * Retrieve PC root certificates
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesRootGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Certificate';
        $request = $this->clustersUuidCertificatesRootGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesRootGet'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesRootGetRequest($uuid, string $contentType = self::contentTypes['clustersUuidCertificatesRootGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesRootGet'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesRootGet, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/{uuid}/certificates/root';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesRootPost
     *
     * Save a PC root certificate on a PC or a PE
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RootCertificate $root_cert root_cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RootCertificate
     */
    public function clustersUuidCertificatesRootPost($uuid, $root_cert, string $contentType = self::contentTypes['clustersUuidCertificatesRootPost'][0])
    {
        list($response) = $this->clustersUuidCertificatesRootPostWithHttpInfo($uuid, $root_cert, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidCertificatesRootPostWithHttpInfo
     *
     * Save a PC root certificate on a PC or a PE
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RootCertificate $root_cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RootCertificate, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesRootPostWithHttpInfo($uuid, $root_cert, string $contentType = self::contentTypes['clustersUuidCertificatesRootPost'][0])
    {
        $request = $this->clustersUuidCertificatesRootPostRequest($uuid, $root_cert, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RootCertificate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RootCertificate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RootCertificate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RootCertificate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RootCertificate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesRootPostAsync
     *
     * Save a PC root certificate on a PC or a PE
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RootCertificate $root_cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesRootPostAsync($uuid, $root_cert, string $contentType = self::contentTypes['clustersUuidCertificatesRootPost'][0])
    {
        return $this->clustersUuidCertificatesRootPostAsyncWithHttpInfo($uuid, $root_cert, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesRootPostAsyncWithHttpInfo
     *
     * Save a PC root certificate on a PC or a PE
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RootCertificate $root_cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesRootPostAsyncWithHttpInfo($uuid, $root_cert, string $contentType = self::contentTypes['clustersUuidCertificatesRootPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RootCertificate';
        $request = $this->clustersUuidCertificatesRootPostRequest($uuid, $root_cert, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesRootPost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RootCertificate $root_cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesRootPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesRootPostRequest($uuid, $root_cert, string $contentType = self::contentTypes['clustersUuidCertificatesRootPost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesRootPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesRootPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'root_cert' is set
        if ($root_cert === null || (is_array($root_cert) && count($root_cert) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $root_cert when calling clustersUuidCertificatesRootPost'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/root';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($root_cert)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($root_cert));
            } else {
                $httpBody = $root_cert;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsKmsUuidPost
     *
     * Add one or more certificates to a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $kms_uuid kms_uuid (required)
     * @param  \OpenAPI\Client\Model\CertificateSpecUploadInput $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesSvmCertsKmsUuidPost($uuid, $kms_uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'][0])
    {
        $this->clustersUuidCertificatesSvmCertsKmsUuidPostWithHttpInfo($uuid, $kms_uuid, $body, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsKmsUuidPostWithHttpInfo
     *
     * Add one or more certificates to a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $kms_uuid (required)
     * @param  \OpenAPI\Client\Model\CertificateSpecUploadInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesSvmCertsKmsUuidPostWithHttpInfo($uuid, $kms_uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'][0])
    {
        $request = $this->clustersUuidCertificatesSvmCertsKmsUuidPostRequest($uuid, $kms_uuid, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsKmsUuidPostAsync
     *
     * Add one or more certificates to a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $kms_uuid (required)
     * @param  \OpenAPI\Client\Model\CertificateSpecUploadInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesSvmCertsKmsUuidPostAsync($uuid, $kms_uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'][0])
    {
        return $this->clustersUuidCertificatesSvmCertsKmsUuidPostAsyncWithHttpInfo($uuid, $kms_uuid, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsKmsUuidPostAsyncWithHttpInfo
     *
     * Add one or more certificates to a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $kms_uuid (required)
     * @param  \OpenAPI\Client\Model\CertificateSpecUploadInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesSvmCertsKmsUuidPostAsyncWithHttpInfo($uuid, $kms_uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesSvmCertsKmsUuidPostRequest($uuid, $kms_uuid, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesSvmCertsKmsUuidPost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $kms_uuid (required)
     * @param  \OpenAPI\Client\Model\CertificateSpecUploadInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesSvmCertsKmsUuidPostRequest($uuid, $kms_uuid, $body, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsKmsUuidPost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesSvmCertsKmsUuidPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesSvmCertsKmsUuidPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'kms_uuid' is set
        if ($kms_uuid === null || (is_array($kms_uuid) && count($kms_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kms_uuid when calling clustersUuidCertificatesSvmCertsKmsUuidPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $kms_uuid)) {
            throw new \InvalidArgumentException("invalid value for \"kms_uuid\" when calling ClustersApi.clustersUuidCertificatesSvmCertsKmsUuidPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clustersUuidCertificatesSvmCertsKmsUuidPost'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/svm_certs/{kms_uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($kms_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'kms_uuid' . '}',
                ObjectSerializer::toPathValue($kms_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete
     *
     * Delete the certificate on a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid node_uuid (required)
     * @param  string $kms_uuid kms_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete($uuid, $node_uuid, $kms_uuid, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'][0])
    {
        $this->clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteWithHttpInfo($uuid, $node_uuid, $kms_uuid, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteWithHttpInfo
     *
     * Delete the certificate on a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid (required)
     * @param  string $kms_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteWithHttpInfo($uuid, $node_uuid, $kms_uuid, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'][0])
    {
        $request = $this->clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteRequest($uuid, $node_uuid, $kms_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteAsync
     *
     * Delete the certificate on a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid (required)
     * @param  string $kms_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteAsync($uuid, $node_uuid, $kms_uuid, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'][0])
    {
        return $this->clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteAsyncWithHttpInfo($uuid, $node_uuid, $kms_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteAsyncWithHttpInfo
     *
     * Delete the certificate on a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid (required)
     * @param  string $kms_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteAsyncWithHttpInfo($uuid, $node_uuid, $kms_uuid, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteRequest($uuid, $node_uuid, $kms_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid (required)
     * @param  string $kms_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDeleteRequest($uuid, $node_uuid, $kms_uuid, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'node_uuid' is set
        if ($node_uuid === null || (is_array($node_uuid) && count($node_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node_uuid when calling clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $node_uuid)) {
            throw new \InvalidArgumentException("invalid value for \"node_uuid\" when calling ClustersApi.clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'kms_uuid' is set
        if ($kms_uuid === null || (is_array($kms_uuid) && count($kms_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kms_uuid when calling clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $kms_uuid)) {
            throw new \InvalidArgumentException("invalid value for \"kms_uuid\" when calling ClustersApi.clustersUuidCertificatesSvmCertsNodeUuidKmsUuidDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/{uuid}/certificates/svm_certs/{node_uuid}/{kms_uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($node_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'node_uuid' . '}',
                ObjectSerializer::toPathValue($node_uuid),
                $resourcePath
            );
        }
        // path params
        if ($kms_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'kms_uuid' . '}',
                ObjectSerializer::toPathValue($kms_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut
     *
     * Replace the certificate on a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid node_uuid (required)
     * @param  string $kms_uuid kms_uuid (required)
     * @param  \OpenAPI\Client\Model\Certificate $cert cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut($uuid, $node_uuid, $kms_uuid, $cert, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'][0])
    {
        $this->clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutWithHttpInfo($uuid, $node_uuid, $kms_uuid, $cert, $contentType);
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutWithHttpInfo
     *
     * Replace the certificate on a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid (required)
     * @param  string $kms_uuid (required)
     * @param  \OpenAPI\Client\Model\Certificate $cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutWithHttpInfo($uuid, $node_uuid, $kms_uuid, $cert, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'][0])
    {
        $request = $this->clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutRequest($uuid, $node_uuid, $kms_uuid, $cert, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutAsync
     *
     * Replace the certificate on a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid (required)
     * @param  string $kms_uuid (required)
     * @param  \OpenAPI\Client\Model\Certificate $cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutAsync($uuid, $node_uuid, $kms_uuid, $cert, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'][0])
    {
        return $this->clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutAsyncWithHttpInfo($uuid, $node_uuid, $kms_uuid, $cert, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutAsyncWithHttpInfo
     *
     * Replace the certificate on a service VM
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid (required)
     * @param  string $kms_uuid (required)
     * @param  \OpenAPI\Client\Model\Certificate $cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutAsyncWithHttpInfo($uuid, $node_uuid, $kms_uuid, $cert, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'][0])
    {
        $returnType = '';
        $request = $this->clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutRequest($uuid, $node_uuid, $kms_uuid, $cert, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $node_uuid (required)
     * @param  string $kms_uuid (required)
     * @param  \OpenAPI\Client\Model\Certificate $cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPutRequest($uuid, $node_uuid, $kms_uuid, $cert, string $contentType = self::contentTypes['clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'node_uuid' is set
        if ($node_uuid === null || (is_array($node_uuid) && count($node_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node_uuid when calling clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $node_uuid)) {
            throw new \InvalidArgumentException("invalid value for \"node_uuid\" when calling ClustersApi.clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'kms_uuid' is set
        if ($kms_uuid === null || (is_array($kms_uuid) && count($kms_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kms_uuid when calling clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $kms_uuid)) {
            throw new \InvalidArgumentException("invalid value for \"kms_uuid\" when calling ClustersApi.clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'cert' is set
        if ($cert === null || (is_array($cert) && count($cert) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cert when calling clustersUuidCertificatesSvmCertsNodeUuidKmsUuidPut'
            );
        }


        $resourcePath = '/clusters/{uuid}/certificates/svm_certs/{node_uuid}/{kms_uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($node_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'node_uuid' . '}',
                ObjectSerializer::toPathValue($node_uuid),
                $resourcePath
            );
        }
        // path params
        if ($kms_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'kms_uuid' . '}',
                ObjectSerializer::toPathValue($kms_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cert)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cert));
            } else {
                $httpBody = $cert;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete
     *
     * Delete a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'][0])
    {
        list($response) = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteWithHttpInfo
     *
     * Delete a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'][0])
    {
        $request = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteRequest($uuid, $cloud_type, $cloud_credentials_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\CloudCredentialsStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteAsync
     *
     * Delete a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteAsync($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'][0])
    {
        return $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteAsyncWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteAsyncWithHttpInfo
     *
     * Delete a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteAsyncWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
        $request = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteRequest($uuid, $cloud_type, $cloud_credentials_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDeleteRequest($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'cloud_type' is set
        if ($cloud_type === null || (is_array($cloud_type) && count($cloud_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_type when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'
            );
        }
        if (!preg_match("/(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/", $cloud_type)) {
            throw new \InvalidArgumentException("invalid value for \"cloud_type\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete, must conform to the pattern /(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/.");
        }
        
        // verify the required parameter 'cloud_credentials_id' is set
        if ($cloud_credentials_id === null || (is_array($cloud_credentials_id) && count($cloud_credentials_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_credentials_id when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdDelete'
            );
        }


        $resourcePath = '/clusters/{uuid}/cloud_credentials/{cloud_type}/{cloud_credentials_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($cloud_type !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_type' . '}',
                ObjectSerializer::toPathValue($cloud_type),
                $resourcePath
            );
        }
        // path params
        if ($cloud_credentials_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_credentials_id' . '}',
                ObjectSerializer::toPathValue($cloud_credentials_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet
     *
     * Get a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'][0])
    {
        list($response) = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetWithHttpInfo
     *
     * Get a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'][0])
    {
        $request = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetRequest($uuid, $cloud_type, $cloud_credentials_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\CloudCredentialsStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetAsync
     *
     * Get a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetAsync($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'][0])
    {
        return $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetAsyncWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetAsyncWithHttpInfo
     *
     * Get a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetAsyncWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
        $request = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetRequest($uuid, $cloud_type, $cloud_credentials_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGetRequest($uuid, $cloud_type, $cloud_credentials_id, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'cloud_type' is set
        if ($cloud_type === null || (is_array($cloud_type) && count($cloud_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_type when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'
            );
        }
        if (!preg_match("/(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/", $cloud_type)) {
            throw new \InvalidArgumentException("invalid value for \"cloud_type\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet, must conform to the pattern /(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/.");
        }
        
        // verify the required parameter 'cloud_credentials_id' is set
        if ($cloud_credentials_id === null || (is_array($cloud_credentials_id) && count($cloud_credentials_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_credentials_id when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdGet'
            );
        }


        $resourcePath = '/clusters/{uuid}/cloud_credentials/{cloud_type}/{cloud_credentials_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($cloud_type !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_type' . '}',
                ObjectSerializer::toPathValue($cloud_type),
                $resourcePath
            );
        }
        // path params
        if ($cloud_credentials_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_credentials_id' . '}',
                ObjectSerializer::toPathValue($cloud_credentials_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut
     *
     * Update a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id cloud_credentials_id (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut($uuid, $cloud_type, $cloud_credentials_id, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'][0])
    {
        list($response) = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutWithHttpInfo
     *
     * Update a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'][0])
    {
        $request = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutRequest($uuid, $cloud_type, $cloud_credentials_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\CloudCredentialsStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutAsync
     *
     * Update a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutAsync($uuid, $cloud_type, $cloud_credentials_id, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'][0])
    {
        return $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutAsyncWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutAsyncWithHttpInfo
     *
     * Update a existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutAsyncWithHttpInfo($uuid, $cloud_type, $cloud_credentials_id, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
        $request = $this->clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutRequest($uuid, $cloud_type, $cloud_credentials_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  int $cloud_credentials_id (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPutRequest($uuid, $cloud_type, $cloud_credentials_id, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'cloud_type' is set
        if ($cloud_type === null || (is_array($cloud_type) && count($cloud_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_type when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'
            );
        }
        if (!preg_match("/(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/", $cloud_type)) {
            throw new \InvalidArgumentException("invalid value for \"cloud_type\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut, must conform to the pattern /(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/.");
        }
        
        // verify the required parameter 'cloud_credentials_id' is set
        if ($cloud_credentials_id === null || (is_array($cloud_credentials_id) && count($cloud_credentials_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_credentials_id when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clustersUuidCloudCredentialsCloudTypeCloudCredentialsIdPut'
            );
        }


        $resourcePath = '/clusters/{uuid}/cloud_credentials/{cloud_type}/{cloud_credentials_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($cloud_type !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_type' . '}',
                ObjectSerializer::toPathValue($cloud_type),
                $resourcePath
            );
        }
        // path params
        if ($cloud_credentials_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_credentials_id' . '}',
                ObjectSerializer::toPathValue($cloud_credentials_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeDelete
     *
     * Delete all cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus
     */
    public function clustersUuidCloudCredentialsCloudTypeDelete($uuid, $cloud_type, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'][0])
    {
        list($response) = $this->clustersUuidCloudCredentialsCloudTypeDeleteWithHttpInfo($uuid, $cloud_type, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeDeleteWithHttpInfo
     *
     * Delete all cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCloudCredentialsCloudTypeDeleteWithHttpInfo($uuid, $cloud_type, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'][0])
    {
        $request = $this->clustersUuidCloudCredentialsCloudTypeDeleteRequest($uuid, $cloud_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\CloudCredentialsStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeDeleteAsync
     *
     * Delete all cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeDeleteAsync($uuid, $cloud_type, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'][0])
    {
        return $this->clustersUuidCloudCredentialsCloudTypeDeleteAsyncWithHttpInfo($uuid, $cloud_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeDeleteAsyncWithHttpInfo
     *
     * Delete all cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeDeleteAsyncWithHttpInfo($uuid, $cloud_type, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
        $request = $this->clustersUuidCloudCredentialsCloudTypeDeleteRequest($uuid, $cloud_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCloudCredentialsCloudTypeDelete'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCloudCredentialsCloudTypeDeleteRequest($uuid, $cloud_type, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeDelete'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCloudCredentialsCloudTypeDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'cloud_type' is set
        if ($cloud_type === null || (is_array($cloud_type) && count($cloud_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_type when calling clustersUuidCloudCredentialsCloudTypeDelete'
            );
        }
        if (!preg_match("/(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/", $cloud_type)) {
            throw new \InvalidArgumentException("invalid value for \"cloud_type\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeDelete, must conform to the pattern /(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/.");
        }
        

        $resourcePath = '/clusters/{uuid}/cloud_credentials/{cloud_type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($cloud_type !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_type' . '}',
                ObjectSerializer::toPathValue($cloud_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeListPost
     *
     * Get a list of existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsListMetadata $get_entities_request get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CloudCredentialsListIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus
     */
    public function clustersUuidCloudCredentialsCloudTypeListPost($uuid, $cloud_type, $get_entities_request, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'][0])
    {
        list($response) = $this->clustersUuidCloudCredentialsCloudTypeListPostWithHttpInfo($uuid, $cloud_type, $get_entities_request, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeListPostWithHttpInfo
     *
     * Get a list of existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsListMetadata $get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CloudCredentialsListIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCloudCredentialsCloudTypeListPostWithHttpInfo($uuid, $cloud_type, $get_entities_request, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'][0])
    {
        $request = $this->clustersUuidCloudCredentialsCloudTypeListPostRequest($uuid, $cloud_type, $get_entities_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CloudCredentialsListIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsListIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsListIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\CloudCredentialsStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CloudCredentialsListIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsListIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeListPostAsync
     *
     * Get a list of existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsListMetadata $get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeListPostAsync($uuid, $cloud_type, $get_entities_request, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'][0])
    {
        return $this->clustersUuidCloudCredentialsCloudTypeListPostAsyncWithHttpInfo($uuid, $cloud_type, $get_entities_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypeListPostAsyncWithHttpInfo
     *
     * Get a list of existing cloud credentials
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsListMetadata $get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypeListPostAsyncWithHttpInfo($uuid, $cloud_type, $get_entities_request, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CloudCredentialsListIntentResponse';
        $request = $this->clustersUuidCloudCredentialsCloudTypeListPostRequest($uuid, $cloud_type, $get_entities_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCloudCredentialsCloudTypeListPost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsListMetadata $get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCloudCredentialsCloudTypeListPostRequest($uuid, $cloud_type, $get_entities_request, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypeListPost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCloudCredentialsCloudTypeListPost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeListPost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'cloud_type' is set
        if ($cloud_type === null || (is_array($cloud_type) && count($cloud_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_type when calling clustersUuidCloudCredentialsCloudTypeListPost'
            );
        }
        if (!preg_match("/(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/", $cloud_type)) {
            throw new \InvalidArgumentException("invalid value for \"cloud_type\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypeListPost, must conform to the pattern /(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/.");
        }
        
        // verify the required parameter 'get_entities_request' is set
        if ($get_entities_request === null || (is_array($get_entities_request) && count($get_entities_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $get_entities_request when calling clustersUuidCloudCredentialsCloudTypeListPost'
            );
        }


        $resourcePath = '/clusters/{uuid}/cloud_credentials/{cloud_type}/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($cloud_type !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_type' . '}',
                ObjectSerializer::toPathValue($cloud_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($get_entities_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($get_entities_request));
            } else {
                $httpBody = $get_entities_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypePost
     *
     * Add a cloud credential for accessing cloud sites
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus
     */
    public function clustersUuidCloudCredentialsCloudTypePost($uuid, $cloud_type, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'][0])
    {
        list($response) = $this->clustersUuidCloudCredentialsCloudTypePostWithHttpInfo($uuid, $cloud_type, $body, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypePostWithHttpInfo
     *
     * Add a cloud credential for accessing cloud sites
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CloudCredentialsIntentResponse|\OpenAPI\Client\Model\CloudCredentialsStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidCloudCredentialsCloudTypePostWithHttpInfo($uuid, $cloud_type, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'][0])
    {
        $request = $this->clustersUuidCloudCredentialsCloudTypePostRequest($uuid, $cloud_type, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\CloudCredentialsStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CloudCredentialsStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CloudCredentialsStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CloudCredentialsStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypePostAsync
     *
     * Add a cloud credential for accessing cloud sites
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypePostAsync($uuid, $cloud_type, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'][0])
    {
        return $this->clustersUuidCloudCredentialsCloudTypePostAsyncWithHttpInfo($uuid, $cloud_type, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidCloudCredentialsCloudTypePostAsyncWithHttpInfo
     *
     * Add a cloud credential for accessing cloud sites
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidCloudCredentialsCloudTypePostAsyncWithHttpInfo($uuid, $cloud_type, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CloudCredentialsIntentResponse';
        $request = $this->clustersUuidCloudCredentialsCloudTypePostRequest($uuid, $cloud_type, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidCloudCredentialsCloudTypePost'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $cloud_type The Cloud Type. (required)
     * @param  \OpenAPI\Client\Model\CloudCredentialsIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidCloudCredentialsCloudTypePostRequest($uuid, $cloud_type, $body, string $contentType = self::contentTypes['clustersUuidCloudCredentialsCloudTypePost'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidCloudCredentialsCloudTypePost'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypePost, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'cloud_type' is set
        if ($cloud_type === null || (is_array($cloud_type) && count($cloud_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cloud_type when calling clustersUuidCloudCredentialsCloudTypePost'
            );
        }
        if (!preg_match("/(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/", $cloud_type)) {
            throw new \InvalidArgumentException("invalid value for \"cloud_type\" when calling ClustersApi.clustersUuidCloudCredentialsCloudTypePost, must conform to the pattern /(\\bAWS\\b|\\bAZURE\\b|\\bNUTANIX_HOSTED_CLOUD\\b|\\bONPREM_CLOUD\\b)/.");
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clustersUuidCloudCredentialsCloudTypePost'
            );
        }


        $resourcePath = '/clusters/{uuid}/cloud_credentials/{cloud_type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }
        // path params
        if ($cloud_type !== null) {
            $resourcePath = str_replace(
                '{' . 'cloud_type' . '}',
                ObjectSerializer::toPathValue($cloud_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidGet
     *
     * Get a existing cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ClusterIntentResponse|\OpenAPI\Client\Model\ClusterStatus
     */
    public function clustersUuidGet($uuid, string $contentType = self::contentTypes['clustersUuidGet'][0])
    {
        list($response) = $this->clustersUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidGetWithHttpInfo
     *
     * Get a existing cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ClusterIntentResponse|\OpenAPI\Client\Model\ClusterStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidGet'][0])
    {
        $request = $this->clustersUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ClusterIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClusterIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClusterIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ClusterStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClusterStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClusterStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ClusterIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClusterIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClusterStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidGetAsync
     *
     * Get a existing cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidGetAsync($uuid, string $contentType = self::contentTypes['clustersUuidGet'][0])
    {
        return $this->clustersUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidGetAsyncWithHttpInfo
     *
     * Get a existing cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['clustersUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ClusterIntentResponse';
        $request = $this->clustersUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidGet'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidGetRequest($uuid, string $contentType = self::contentTypes['clustersUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidGet'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidGet, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/clusters/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clustersUuidPut
     *
     * Update a existing cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\ClusterIntentInput $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ClusterIntentResponse|\OpenAPI\Client\Model\ClusterStatus
     */
    public function clustersUuidPut($uuid, $body, string $contentType = self::contentTypes['clustersUuidPut'][0])
    {
        list($response) = $this->clustersUuidPutWithHttpInfo($uuid, $body, $contentType);
        return $response;
    }

    /**
     * Operation clustersUuidPutWithHttpInfo
     *
     * Update a existing cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\ClusterIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ClusterIntentResponse|\OpenAPI\Client\Model\ClusterStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function clustersUuidPutWithHttpInfo($uuid, $body, string $contentType = self::contentTypes['clustersUuidPut'][0])
    {
        $request = $this->clustersUuidPutRequest($uuid, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\ClusterIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClusterIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClusterIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ClusterStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClusterStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClusterStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ClusterIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClusterIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClusterStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clustersUuidPutAsync
     *
     * Update a existing cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\ClusterIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidPutAsync($uuid, $body, string $contentType = self::contentTypes['clustersUuidPut'][0])
    {
        return $this->clustersUuidPutAsyncWithHttpInfo($uuid, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clustersUuidPutAsyncWithHttpInfo
     *
     * Update a existing cluster
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\ClusterIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clustersUuidPutAsyncWithHttpInfo($uuid, $body, string $contentType = self::contentTypes['clustersUuidPut'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ClusterIntentResponse';
        $request = $this->clustersUuidPutRequest($uuid, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clustersUuidPut'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\ClusterIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clustersUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clustersUuidPutRequest($uuid, $body, string $contentType = self::contentTypes['clustersUuidPut'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling clustersUuidPut'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling ClustersApi.clustersUuidPut, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clustersUuidPut'
            );
        }


        $resourcePath = '/clusters/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
