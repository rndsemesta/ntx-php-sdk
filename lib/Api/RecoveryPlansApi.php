<?php
/**
 * RecoveryPlansApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Nutanix Intentful API
 *
 * Move programming from the user to the machine.
 *
 * The version of the OpenAPI document: 3.1.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * RecoveryPlansApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RecoveryPlansApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'recoveryPlansListPost' => [
            'application/json',
        ],
        'recoveryPlansPost' => [
            'application/json',
        ],
        'recoveryPlansUuidDelete' => [
            'application/json',
        ],
        'recoveryPlansUuidEntitiesGet' => [
            'application/json',
        ],
        'recoveryPlansUuidGet' => [
            'application/json',
        ],
        'recoveryPlansUuidPut' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation recoveryPlansListPost
     *
     * List the Recovery Plans
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanListMetadata $get_entities_request get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansListPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RecoveryPlanListIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus
     */
    public function recoveryPlansListPost($get_entities_request, string $contentType = self::contentTypes['recoveryPlansListPost'][0])
    {
        list($response) = $this->recoveryPlansListPostWithHttpInfo($get_entities_request, $contentType);
        return $response;
    }

    /**
     * Operation recoveryPlansListPostWithHttpInfo
     *
     * List the Recovery Plans
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanListMetadata $get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansListPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RecoveryPlanListIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function recoveryPlansListPostWithHttpInfo($get_entities_request, string $contentType = self::contentTypes['recoveryPlansListPost'][0])
    {
        $request = $this->recoveryPlansListPostRequest($get_entities_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RecoveryPlanListIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanListIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanListIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RecoveryPlanListIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanListIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recoveryPlansListPostAsync
     *
     * List the Recovery Plans
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanListMetadata $get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansListPostAsync($get_entities_request, string $contentType = self::contentTypes['recoveryPlansListPost'][0])
    {
        return $this->recoveryPlansListPostAsyncWithHttpInfo($get_entities_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recoveryPlansListPostAsyncWithHttpInfo
     *
     * List the Recovery Plans
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanListMetadata $get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansListPostAsyncWithHttpInfo($get_entities_request, string $contentType = self::contentTypes['recoveryPlansListPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RecoveryPlanListIntentResponse';
        $request = $this->recoveryPlansListPostRequest($get_entities_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recoveryPlansListPost'
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanListMetadata $get_entities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recoveryPlansListPostRequest($get_entities_request, string $contentType = self::contentTypes['recoveryPlansListPost'][0])
    {

        // verify the required parameter 'get_entities_request' is set
        if ($get_entities_request === null || (is_array($get_entities_request) && count($get_entities_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $get_entities_request when calling recoveryPlansListPost'
            );
        }


        $resourcePath = '/recovery_plans/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($get_entities_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($get_entities_request));
            } else {
                $httpBody = $get_entities_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recoveryPlansPost
     *
     * Create Recovery Plan
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body Request body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RecoveryPlanIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus
     */
    public function recoveryPlansPost($body, string $contentType = self::contentTypes['recoveryPlansPost'][0])
    {
        list($response) = $this->recoveryPlansPostWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation recoveryPlansPostWithHttpInfo
     *
     * Create Recovery Plan
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body Request body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RecoveryPlanIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function recoveryPlansPostWithHttpInfo($body, string $contentType = self::contentTypes['recoveryPlansPost'][0])
    {
        $request = $this->recoveryPlansPostRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\RecoveryPlanIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RecoveryPlanIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recoveryPlansPostAsync
     *
     * Create Recovery Plan
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body Request body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansPostAsync($body, string $contentType = self::contentTypes['recoveryPlansPost'][0])
    {
        return $this->recoveryPlansPostAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recoveryPlansPostAsyncWithHttpInfo
     *
     * Create Recovery Plan
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body Request body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansPostAsyncWithHttpInfo($body, string $contentType = self::contentTypes['recoveryPlansPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RecoveryPlanIntentResponse';
        $request = $this->recoveryPlansPostRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recoveryPlansPost'
     *
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body Request body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recoveryPlansPostRequest($body, string $contentType = self::contentTypes['recoveryPlansPost'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling recoveryPlansPost'
            );
        }


        $resourcePath = '/recovery_plans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recoveryPlansUuidDelete
     *
     * Delete Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RecoveryPlanStatus|\OpenAPI\Client\Model\RecoveryPlanIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus
     */
    public function recoveryPlansUuidDelete($uuid, string $contentType = self::contentTypes['recoveryPlansUuidDelete'][0])
    {
        list($response) = $this->recoveryPlansUuidDeleteWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation recoveryPlansUuidDeleteWithHttpInfo
     *
     * Delete Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RecoveryPlanStatus|\OpenAPI\Client\Model\RecoveryPlanIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function recoveryPlansUuidDeleteWithHttpInfo($uuid, string $contentType = self::contentTypes['recoveryPlansUuidDelete'][0])
    {
        $request = $this->recoveryPlansUuidDeleteRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 404:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\OpenAPI\Client\Model\RecoveryPlanIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RecoveryPlanIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recoveryPlansUuidDeleteAsync
     *
     * Delete Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansUuidDeleteAsync($uuid, string $contentType = self::contentTypes['recoveryPlansUuidDelete'][0])
    {
        return $this->recoveryPlansUuidDeleteAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recoveryPlansUuidDeleteAsyncWithHttpInfo
     *
     * Delete Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansUuidDeleteAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['recoveryPlansUuidDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RecoveryPlanIntentResponse';
        $request = $this->recoveryPlansUuidDeleteRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recoveryPlansUuidDelete'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recoveryPlansUuidDeleteRequest($uuid, string $contentType = self::contentTypes['recoveryPlansUuidDelete'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling recoveryPlansUuidDelete'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling RecoveryPlansApi.recoveryPlansUuidDelete, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/recovery_plans/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recoveryPlansUuidEntitiesGet
     *
     * Get entities associated with the Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $action_type The entities that will be recovered when an operation is performed on the Recovery Plan. Below is the list of supported action types. MIGRATE - Entities will be recovered from their latest state in the   Recovery Availability Zone. LIVE_MIGRATE - Entities will be recovered from their latest state   in the Recovery Availability Zone without VM down time. FAILOVER - Entities will be recovered from a Recovery Point at   Recovery Availability Zone. TEST_FAILOVER - Entities will be recovered from the latest Recovery   Point in the test network. (optional)
     * @param  string[] $failed_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  string[] $recovery_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  \DateTime $recovery_reference_time Time with respect to which entities has to be fetched for Unplanned Failover. This time will be used as reference time with respect to which latest snapshot will have to be restored in case of failover. For example, if failover is required to be done using snapshot created on or before yesterday &#39;2:00&#39; PM, then recovery_reference_time will be set to this time. This would be given in the format %Y-%m-%dT%H:%M:%SZ. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidEntitiesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RecoveryPlanEntities|\OpenAPI\Client\Model\RecoveryPlanStatus
     */
    public function recoveryPlansUuidEntitiesGet($uuid, $action_type = null, $failed_availability_zone_info_list = null, $recovery_availability_zone_info_list = null, $recovery_reference_time = null, string $contentType = self::contentTypes['recoveryPlansUuidEntitiesGet'][0])
    {
        list($response) = $this->recoveryPlansUuidEntitiesGetWithHttpInfo($uuid, $action_type, $failed_availability_zone_info_list, $recovery_availability_zone_info_list, $recovery_reference_time, $contentType);
        return $response;
    }

    /**
     * Operation recoveryPlansUuidEntitiesGetWithHttpInfo
     *
     * Get entities associated with the Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $action_type The entities that will be recovered when an operation is performed on the Recovery Plan. Below is the list of supported action types. MIGRATE - Entities will be recovered from their latest state in the   Recovery Availability Zone. LIVE_MIGRATE - Entities will be recovered from their latest state   in the Recovery Availability Zone without VM down time. FAILOVER - Entities will be recovered from a Recovery Point at   Recovery Availability Zone. TEST_FAILOVER - Entities will be recovered from the latest Recovery   Point in the test network. (optional)
     * @param  string[] $failed_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  string[] $recovery_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  \DateTime $recovery_reference_time Time with respect to which entities has to be fetched for Unplanned Failover. This time will be used as reference time with respect to which latest snapshot will have to be restored in case of failover. For example, if failover is required to be done using snapshot created on or before yesterday &#39;2:00&#39; PM, then recovery_reference_time will be set to this time. This would be given in the format %Y-%m-%dT%H:%M:%SZ. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidEntitiesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RecoveryPlanEntities|\OpenAPI\Client\Model\RecoveryPlanStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function recoveryPlansUuidEntitiesGetWithHttpInfo($uuid, $action_type = null, $failed_availability_zone_info_list = null, $recovery_availability_zone_info_list = null, $recovery_reference_time = null, string $contentType = self::contentTypes['recoveryPlansUuidEntitiesGet'][0])
    {
        $request = $this->recoveryPlansUuidEntitiesGetRequest($uuid, $action_type, $failed_availability_zone_info_list, $recovery_availability_zone_info_list, $recovery_reference_time, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RecoveryPlanEntities' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanEntities' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanEntities', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RecoveryPlanEntities';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanEntities',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recoveryPlansUuidEntitiesGetAsync
     *
     * Get entities associated with the Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $action_type The entities that will be recovered when an operation is performed on the Recovery Plan. Below is the list of supported action types. MIGRATE - Entities will be recovered from their latest state in the   Recovery Availability Zone. LIVE_MIGRATE - Entities will be recovered from their latest state   in the Recovery Availability Zone without VM down time. FAILOVER - Entities will be recovered from a Recovery Point at   Recovery Availability Zone. TEST_FAILOVER - Entities will be recovered from the latest Recovery   Point in the test network. (optional)
     * @param  string[] $failed_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  string[] $recovery_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  \DateTime $recovery_reference_time Time with respect to which entities has to be fetched for Unplanned Failover. This time will be used as reference time with respect to which latest snapshot will have to be restored in case of failover. For example, if failover is required to be done using snapshot created on or before yesterday &#39;2:00&#39; PM, then recovery_reference_time will be set to this time. This would be given in the format %Y-%m-%dT%H:%M:%SZ. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidEntitiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansUuidEntitiesGetAsync($uuid, $action_type = null, $failed_availability_zone_info_list = null, $recovery_availability_zone_info_list = null, $recovery_reference_time = null, string $contentType = self::contentTypes['recoveryPlansUuidEntitiesGet'][0])
    {
        return $this->recoveryPlansUuidEntitiesGetAsyncWithHttpInfo($uuid, $action_type, $failed_availability_zone_info_list, $recovery_availability_zone_info_list, $recovery_reference_time, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recoveryPlansUuidEntitiesGetAsyncWithHttpInfo
     *
     * Get entities associated with the Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $action_type The entities that will be recovered when an operation is performed on the Recovery Plan. Below is the list of supported action types. MIGRATE - Entities will be recovered from their latest state in the   Recovery Availability Zone. LIVE_MIGRATE - Entities will be recovered from their latest state   in the Recovery Availability Zone without VM down time. FAILOVER - Entities will be recovered from a Recovery Point at   Recovery Availability Zone. TEST_FAILOVER - Entities will be recovered from the latest Recovery   Point in the test network. (optional)
     * @param  string[] $failed_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  string[] $recovery_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  \DateTime $recovery_reference_time Time with respect to which entities has to be fetched for Unplanned Failover. This time will be used as reference time with respect to which latest snapshot will have to be restored in case of failover. For example, if failover is required to be done using snapshot created on or before yesterday &#39;2:00&#39; PM, then recovery_reference_time will be set to this time. This would be given in the format %Y-%m-%dT%H:%M:%SZ. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidEntitiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansUuidEntitiesGetAsyncWithHttpInfo($uuid, $action_type = null, $failed_availability_zone_info_list = null, $recovery_availability_zone_info_list = null, $recovery_reference_time = null, string $contentType = self::contentTypes['recoveryPlansUuidEntitiesGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RecoveryPlanEntities';
        $request = $this->recoveryPlansUuidEntitiesGetRequest($uuid, $action_type, $failed_availability_zone_info_list, $recovery_availability_zone_info_list, $recovery_reference_time, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recoveryPlansUuidEntitiesGet'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $action_type The entities that will be recovered when an operation is performed on the Recovery Plan. Below is the list of supported action types. MIGRATE - Entities will be recovered from their latest state in the   Recovery Availability Zone. LIVE_MIGRATE - Entities will be recovered from their latest state   in the Recovery Availability Zone without VM down time. FAILOVER - Entities will be recovered from a Recovery Point at   Recovery Availability Zone. TEST_FAILOVER - Entities will be recovered from the latest Recovery   Point in the test network. (optional)
     * @param  string[] $failed_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  string[] $recovery_availability_zone_info_list List of Availability Zone URL and cluster UUIDs. Sample format is \&quot;&lt;az_url&gt;|&lt;cluster_uuid_1&gt;|&lt;cluster_uuid_2&gt;|...\&quot; where cluster_uuids are optional. (optional)
     * @param  \DateTime $recovery_reference_time Time with respect to which entities has to be fetched for Unplanned Failover. This time will be used as reference time with respect to which latest snapshot will have to be restored in case of failover. For example, if failover is required to be done using snapshot created on or before yesterday &#39;2:00&#39; PM, then recovery_reference_time will be set to this time. This would be given in the format %Y-%m-%dT%H:%M:%SZ. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidEntitiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recoveryPlansUuidEntitiesGetRequest($uuid, $action_type = null, $failed_availability_zone_info_list = null, $recovery_availability_zone_info_list = null, $recovery_reference_time = null, string $contentType = self::contentTypes['recoveryPlansUuidEntitiesGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling recoveryPlansUuidEntitiesGet'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling RecoveryPlansApi.recoveryPlansUuidEntitiesGet, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        





        $resourcePath = '/recovery_plans/{uuid}/entities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_type,
            'action_type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $failed_availability_zone_info_list,
            'failed_availability_zone_info_list', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recovery_availability_zone_info_list,
            'recovery_availability_zone_info_list', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recovery_reference_time,
            'recovery_reference_time', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recoveryPlansUuidGet
     *
     * Get Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RecoveryPlanIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus|\OpenAPI\Client\Model\RecoveryPlanStatus
     */
    public function recoveryPlansUuidGet($uuid, string $contentType = self::contentTypes['recoveryPlansUuidGet'][0])
    {
        list($response) = $this->recoveryPlansUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation recoveryPlansUuidGetWithHttpInfo
     *
     * Get Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RecoveryPlanIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus|\OpenAPI\Client\Model\RecoveryPlanStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function recoveryPlansUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['recoveryPlansUuidGet'][0])
    {
        $request = $this->recoveryPlansUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RecoveryPlanIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RecoveryPlanIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recoveryPlansUuidGetAsync
     *
     * Get Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansUuidGetAsync($uuid, string $contentType = self::contentTypes['recoveryPlansUuidGet'][0])
    {
        return $this->recoveryPlansUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recoveryPlansUuidGetAsyncWithHttpInfo
     *
     * Get Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['recoveryPlansUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RecoveryPlanIntentResponse';
        $request = $this->recoveryPlansUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recoveryPlansUuidGet'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recoveryPlansUuidGetRequest($uuid, string $contentType = self::contentTypes['recoveryPlansUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling recoveryPlansUuidGet'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling RecoveryPlansApi.recoveryPlansUuidGet, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        

        $resourcePath = '/recovery_plans/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recoveryPlansUuidPut
     *
     * Update Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RecoveryPlanStatus|\OpenAPI\Client\Model\RecoveryPlanIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus
     */
    public function recoveryPlansUuidPut($uuid, $body, string $contentType = self::contentTypes['recoveryPlansUuidPut'][0])
    {
        list($response) = $this->recoveryPlansUuidPutWithHttpInfo($uuid, $body, $contentType);
        return $response;
    }

    /**
     * Operation recoveryPlansUuidPutWithHttpInfo
     *
     * Update Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RecoveryPlanStatus|\OpenAPI\Client\Model\RecoveryPlanIntentResponse|\OpenAPI\Client\Model\RecoveryPlanStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function recoveryPlansUuidPutWithHttpInfo($uuid, $body, string $contentType = self::contentTypes['recoveryPlansUuidPut'][0])
    {
        $request = $this->recoveryPlansUuidPutRequest($uuid, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 404:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\OpenAPI\Client\Model\RecoveryPlanIntentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanIntentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanIntentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\RecoveryPlanStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RecoveryPlanStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RecoveryPlanStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RecoveryPlanIntentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanIntentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RecoveryPlanStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recoveryPlansUuidPutAsync
     *
     * Update Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansUuidPutAsync($uuid, $body, string $contentType = self::contentTypes['recoveryPlansUuidPut'][0])
    {
        return $this->recoveryPlansUuidPutAsyncWithHttpInfo($uuid, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recoveryPlansUuidPutAsyncWithHttpInfo
     *
     * Update Recovery Plan
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recoveryPlansUuidPutAsyncWithHttpInfo($uuid, $body, string $contentType = self::contentTypes['recoveryPlansUuidPut'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RecoveryPlanIntentResponse';
        $request = $this->recoveryPlansUuidPutRequest($uuid, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recoveryPlansUuidPut'
     *
     * @param  string $uuid The UUID of the entity. (required)
     * @param  \OpenAPI\Client\Model\RecoveryPlanIntentInput $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recoveryPlansUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recoveryPlansUuidPutRequest($uuid, $body, string $contentType = self::contentTypes['recoveryPlansUuidPut'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling recoveryPlansUuidPut'
            );
        }
        if (!preg_match("/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/", $uuid)) {
            throw new \InvalidArgumentException("invalid value for \"uuid\" when calling RecoveryPlansApi.recoveryPlansUuidPut, must conform to the pattern /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.");
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling recoveryPlansUuidPut'
            );
        }


        $resourcePath = '/recovery_plans/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
